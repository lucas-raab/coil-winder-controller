<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_WindingControl" Id="{2bf4d53e-3c0a-48b3-b562-160f25601b83}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_WindingControl
VAR_INPUT
	// Input hmi connection from MAIN
	hmiConnection   : POINTER TO FB_hmi_connection;   // HMI connection
	eventLogger     : POINTER TO FB_EventLogger;      // Event logger
	fileReadWrite   : POINTER TO FB_fileReadWrite;    // File read/write
END_VAR

VAR
	// Temporary testing vars

	// Function Blocks

	// CONTROL VARS
	desiredTension          : LREAL := 0;         // Desired tension
	desiredLinspeed         : LREAL := 0;         // Desired linear speed
	unwinding               : BOOL  := FALSE;     // Unwinding flag
	desiredTurnCountPickup  : DINT  := 0;         // Desired turn count for pickup
	
	// Exit conditions
	target_turn_count       : DINT  := 0;         // Target turn count

	// STATUS VARS
	state                   : INT   := 0;         // State for state machine
	cnt                     : UINT  := 0;         // PLC cycle counter
	eta                     : LREAL := 0;         // Time till completion in seconds
	etaFormattedString      : STRING(255);        // Formatted ETA in format ETA: M:S
	progressPercent         : LREAL := 0;         // Progress percentage (0 to 100) based on turn count

	// COIL MODELS (currently not used)
	// coil_model_base_Xcords : ARRAY[0..MAX_COIL_TYPE_COUNT] OF ARRAY[1..MAX_SIZE_COIL_MODEL] OF LREAL;
	// coil_model_base_Ycords : ARRAY[0..MAX_COIL_TYPE_COUNT] OF ARRAY[1..MAX_SIZE_COIL_MODEL] OF LREAL;

	// coil_model_rot_Xcords  : ARRAY[0..MAX_COIL_TYPE_COUNT] OF ARRAY[1..MAX_SIZE_COIL_MODEL] OF LREAL;
	// coil_model_rot_Ycords  : ARRAY[0..MAX_COIL_TYPE_COUNT] OF ARRAY[1..MAX_SIZE_COIL_MODEL] OF LREAL;

	// AXIS LIST
	payoff_axis_list        : ARRAY[1..GVL.MAX_PAYOFF_COUNT] OF FB_Axis;   // Payoff axis list
	pickup_axis_list        : ARRAY[1..GVL.MAX_PICKUP_COUNT] OF FB_Axis;   // Pickup axis list
	axis_list 				: ARRAY[1..GVL.MAX_PAYOFF_COUNT+GVL.MAX_PICKUP_COUNT] OF FB_Axis; //contains pointers to all axies. 1 being pickup, 2,3,4 being payoff
	// MISC
	numOfEnabledPayoff      : INT := 0;           // Number of enabled payoffs
	tStart                  : TIME;               // Start time
	tEnd                    : TIME;               // End time
	tElapsed                : TIME;               // Elapsed time
	


END_VAR

VAR CONSTANT
	input_bounds            : input_bounds;       // Input bounds
	MAX_COIL_TYPE_COUNT     : INT := 1;           // Number of coil types (counts from 0)
	MAX_SIZE_COIL_MODEL     : INT := 1205;        // Maximum size of coil model
	TARGET_PICKUP_FORCE     : LREAL := 10;        // Target pickup force
	pi                      : LREAL := 4 * ATAN(1); // PI for math reasons (might be built-in but couldn't find it)
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Methods" Id="{b393cdcb-7058-41c2-9d03-a8f8d00b2dde}">
      <Folder Name="Axis Control" Id="{49ec2768-53b2-482d-b44d-ec52fe555e63}" />
      <Folder Name="Error Checks" Id="{dad124df-88d7-4412-bdba-255c48b7272a}" />
      <Folder Name="Exit Checks" Id="{866f0ce9-c940-4c68-80f5-47885684bea2}" />
      <Folder Name="HMI updates" Id="{df5bfcf9-c740-45ae-b19d-3c3cd0aca00f}" />
      <Folder Name="Init Methods" Id="{313976c9-8371-4349-a1d4-ac334e51a051}" />
      <Folder Name="Input Checks" Id="{3dff40f9-587b-485b-8ffe-a3d1acaecd62}" />
      <Folder Name="MISC" Id="{df8274f9-8bfd-43c2-9dbf-d95ad8873f48}" />
      <Folder Name="Motor Control" Id="{4367b06a-8be7-4cee-a828-1c414585ef9d}" />
      <Folder Name="Status Updates" Id="{912579cd-d079-4ec8-869a-781310624225}" />
    </Folder>
    <Method Name="accelerating_tension" Id="{51b0940c-2da9-428b-aa7c-7aa4bc946ef3}" FolderPath="Methods\Motor Control\">
      <Declaration><![CDATA[METHOD accelerating_tension : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
	pickupLinspeed: LREAL;
	dist: LREAL;
	desiredVelocity: LREAL;
	adjustedVelocity: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF unwinding THEN
	//to do update with unwinding feature
	//seg fault to exit program :D remove when implmenting 
	i:=0;
	pickup_axis_list[i].acceleration:=0;
ELSE
	


	pickup_axis_list[1].torque:=desiredTension*	pickup_axis_list[1].getDistToAxis();
	
	//TO DO need to find what to set these to. 
	// to do . velo limits do not function how I thought they would need to ask beckhoff how they work.
	pickup_axis_list[1].velocityLimitLow:=(desiredLinspeed/pickup_axis_list[1].getDistToAxis())*57.29578;
	pickup_axis_list[1].velocityLimitHigh:=1000000 ;
	
	pickup_axis_list[1].setTorque();
	
	pickupLinspeed:=pickup_axis_list[1].AXIS.NcToPlc.ActVelo*	pickup_axis_list[1].getDistToAxis()/57.2957;
	
	
	
	FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
		IF payoff_axis_list[i].enabled THEN
			//ASSUMING CONTINOUS UPDATE LIKE FUNCTION
			//TO DO figure out directions
			
			
			payoff_axis_list[i].setVelocity();
			dist:=payoff_axis_list[i].getDistToAxis();
			
			
			desiredVelocity:=(desiredLinspeed/dist)*57.29578;
			adjustedVelocity:=(pickupLinspeed/dist)*57.29578;
			
			
			//sets payoff axis to half way point between target linspeed and the actual linspeed.
			//i hope that this will give the pickup motor time to ramp up, while not giving too much speed to these motors.
			payoff_axis_list[i].velocity:=(desiredVelocity+adjustedVelocity)/2;
			
			
			
		END_IF
	END_FOR 
END_IF
	
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="all_check" Id="{3616b09d-79ac-4d4e-a9a8-9c800c9db7f0}" FolderPath="Methods\Input Checks\">
      <Declaration><![CDATA[METHOD all_check : BOOL
VAR_INPUT
	write: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[all_check:= all_check OR general_input_check(write:=write);
all_check:= all_check OR payoff_input_check(write:=write);
all_check:=all_check OR pickup_input_check(write:=write);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="count_enabled_motors" Id="{4a842378-88e5-40ee-b5f2-32e4ab95fb86}" FolderPath="Methods\Axis Control\">
      <Declaration><![CDATA[METHOD count_enabled_motors : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[ //updates status of all axises, pickup and payoff

numOfEnabledPayoff:=0;

FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
IF	payoff_axis_list[i].enabled THEN
	numOfEnabledPayoff:=numOfEnabledPayoff+1;
END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="CYCLIC" Id="{66242b1c-4d63-4218-b0e7-5f4fc34ce9db}">
      <Declaration><![CDATA[METHOD CYCLIC : BOOL
VAR
	
	i: INT;
	

	intital: BOOL;
	errorOutput: BOOL;
	errorStatus: BOOL;
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//cycle counter
cnt := cnt +1;

//-------------------------------------------------------------------------------------------------------------- USER INPUT --------------------------------------------------------------------------------------------------------------
	CASE state OF
		10:
		// ========================================10========================================
		
		IF hmiConnection^.resetUI THEN
		reset();
		hmiConnection^.resetUI:=FALSE;
		END_IF
	
		IF hmiConnection^.startUI THEN
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
				 msgFmtStr := 'Error Occured. Unable to start winding while not in tension state',
				 strArg:= '');
			hmiConnection^.startUI:=FALSE;
			
		END_IF
		IF hmiConnection^.tensionUI THEN
		state:=20;
		errorOutput:=TRUE;
		END_IF
	
		//check inputs button
		transfer_hmi_vars();
		
		IF hmiConnection^.homeUI THEN
			state:=50;
			errorOutput:=TRUE;
		END_IF
		
		IF hmiConnection^.estopHW THEN
			state:=500;

		END_IF
		
		
		// ========================================10========================================
		
		20,21:
		// ========================================20========================================
		
		//tension button
		IF hmiConnection^.resetUI THEN
		reset();
		hmiConnection^.resetUI:=FALSE;
		END_IF
	
		//start button
		IF hmiConnection^.startUI THEN
			state:=30;
			errorOutput:=TRUE;
		END_IF
		
		//tension button
		IF NOT hmiConnection^.tensionUI THEN
		state:=10;
		errorOutput:=TRUE;
		END_IF
	
		//check inputs button
		transfer_hmi_vars();
		
		IF hmiConnection^.homeUI THEN
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
				 msgFmtStr := 'Error Occured. Unable to home outside of standby state',
				 strArg:= '');
			hmiConnection^.homeUI:=FALSE;
		END_IF
		
		IF hmiConnection^.estopHW THEN
			state:=500;

		END_IF
		
		// ========================================20========================================
		
		30,31,32,33:
		// ========================================30========================================
		
		//tension button
		IF hmiConnection^.resetUI THEN
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
				 msgFmtStr := 'Error Occured. Unable to reset during winding. Please pause winding.',
				 strArg:= '');
			hmiConnection^.resetUI:=FALSE;
			
		END_IF
	
		//start button
		IF NOT hmiConnection^.startUI THEN
			state:=20;
			errorOutput:=TRUE;
		END_IF
		
		//tension button
		IF NOT hmiConnection^.tensionUI THEN
			hmiConnection^.startUI:=FALSE;
			state:=10;
			errorOutput:=TRUE;
		END_IF
	
		//check inputs button
		IF hmiConnection^.checkInputsUI THEN
			all_check(write:=FALSE);
			hmiConnection^.checkInputsUI:=FALSE;
			errorOutput:=TRUE;
		END_IF
		
		//update inputs button
		IF hmiConnection^.updateInputsUI THEN
			all_check(write:=TRUE);
			hmiConnection^.updateInputsUI:=FALSE;
			
		END_IF
		
		IF hmiConnection^.homeUI THEN
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
				 msgFmtStr := 'Error Occured. Unable to home outside of standby state',
				 strArg:= '');
			hmiConnection^.homeUI:=FALSE;
		END_IF
		
		IF hmiConnection^.estopHW THEN
			state:=500;

		END_IF
		// ========================================30========================================
		
		
		40,41:
		// ========================================40========================================
		//tension button
		IF  hmiConnection^.tensionUI THEN
			state:=40;
			errorOutput:=TRUE;
		ELSE
			state:=41;
			
		END_IF
		
		//reset button
		IF hmiConnection^.resetUI THEN
			reset();
			hmiConnection^.resetUI:=FALSE;
			
		END_IF
	
		//start button
		IF hmiConnection^.startUI THEN
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
				 msgFmtStr := 'Error Occured. Unable to start while finished. Please reset first.',
				 strArg:= '');
			hmiConnection^.resetUI:=FALSE;
			
		END_IF
		
		//check inputs button
		IF hmiConnection^.checkInputsUI THEN
			all_check(write:=FALSE);
			hmiConnection^.checkInputsUI:=FALSE;
		END_IF
		
		//update inputs button
		IF hmiConnection^.updateInputsUI THEN
			all_check(write:=TRUE);
			hmiConnection^.updateInputsUI:= FALSE;
			
		END_IF
		
		IF hmiConnection^.homeUI THEN
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
				 msgFmtStr := 'Error Occured. Unable to home outside of standby state',
				 strArg:= '');
			hmiConnection^.homeUI:=FALSE;
		END_IF
		
		IF hmiConnection^.estopHW THEN
			state:=500;

		END_IF
		// ========================================40========================================

		// ========================================400========================================
		400:
			
		
		//reset button
		IF hmiConnection^.resetUI THEN
			reset();
			state:=10;
			hmiConnection^.resetUI:=FALSE;
			errorOutput:=TRUE;
		END_IF
	
		//start button
		IF hmiConnection^.startUI THEN
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
				 msgFmtStr := 'Error Occured. Unable to start while in error state. Please reset first, and resolve error.',
				 strArg:= '');
			hmiConnection^.resetUI:=FALSE;
			
		END_IF
		
		//check inputs button
		IF hmiConnection^.checkInputsUI THEN
			all_check(write:=FALSE);
			hmiConnection^.checkInputsUI:=FALSE;
		END_IF
		
		//update inputs button
		IF hmiConnection^.updateInputsUI THEN
			all_check(write:=TRUE);
			hmiConnection^.updateInputsUI:= FALSE;
			
		END_IF
		
		IF hmiConnection^.homeUI THEN
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
				 msgFmtStr := 'Error Occured. Unable to home inside error state. Please resolve errors on enabled axises',
				 strArg:= '');
			hmiConnection^.homeUI:=FALSE;
		END_IF
		
		IF hmiConnection^.estopHW THEN
			state:=500;

		END_IF
		// ========================================400========================================
		
		// =======================================50========================================
		50:
		IF  hmiConnection^.tensionUI THEN
				ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
				 msgFmtStr := 'Error Occured. Unable to tension while in homing sdtate. Please stop homing.',
				 strArg:= '');
			hmiConnection^.resetUI:=FALSE;
			
		END_IF
		
		//reset button
		IF hmiConnection^.resetUI THEN
			reset();
			state:=10;
			hmiConnection^.resetUI:=FALSE;
			errorOutput:=TRUE;
		END_IF
	
		//start button
		IF hmiConnection^.startUI THEN
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
				 msgFmtStr := 'Error Occured. Unable to start while in homing sdtate. Please stop homing.',
				 strArg:= '');
			hmiConnection^.resetUI:=FALSE;
			
		END_IF
		
		//check inputs button
		transfer_hmi_vars();
		
		IF hmiConnection^.homeUI THEN
			
			hmiConnection^.homeUI:=FALSE;
			state:=10;
			errorOutput:=TRUE;
		END_IF
		
		IF hmiConnection^.estopHW THEN
			state:=500;

		END_IF
		// ========================================50========================================
		
		// =======================================500========================================
		500:
		IF  hmiConnection^.tensionUI THEN
				ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
				 msgFmtStr := 'Error Occured. Unable to tension while in ESTOP state. Please reset first.',
				 strArg:= '');
			hmiConnection^.tensionUI:=FALSE;
			
		END_IF
		
		//reset button
		IF hmiConnection^.resetUI THEN
			reset();
			state:=10;
			hmiConnection^.resetUI:=FALSE;
			errorOutput:=TRUE;
		END_IF
	
		//start button
		IF hmiConnection^.startUI THEN
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
				 msgFmtStr := 'Error Occured. Unable to start while in ESTOP state. Please reset first.',
				 strArg:= '');
			hmiConnection^.startUI:=FALSE;
			
		END_IF
		
		//check inputs button
		IF hmiConnection^.checkInputsUI THEN
			all_check(write:=FALSE);
			hmiConnection^.checkInputsUI:=FALSE;
		END_IF
		
		//update inputs button
		IF hmiConnection^.updateInputsUI THEN
			all_check(write:=TRUE);
			hmiConnection^.updateInputsUI:= FALSE;
			
		END_IF
		
		IF hmiConnection^.homeUI THEN
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
			msgFmtStr := 'Error Occured. Unable to home while in ESTOP state. Please reset first.',
			strArg:= '');
			hmiConnection^.homeUI:=FALSE;
		END_IF
		
		IF hmiConnection^.estopHW THEN
			state:=500;

		END_IF
		// ========================================500========================================
	END_CASE
//-------------------------------------------------------------------------------------------------------------- USER INPUT --------------------------------------------------------------------------------------------------------------
	
//clear status vars for axis. we will update them depending on our current state.
pickup_axis_list[1].setClear();

FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	payoff_axis_list[i].setClear();
END_FOR

//check FOR error, IF error THEN set state TO 400

general_error_check(errorStatus=>errorStatus,errorOutput:=errorOutput);


//if no error, but currently in error state set winding to standby
//if none of the above state is unmodified
IF errorStatus THEN
	state:=400;
ELSIF state=400 AND NOT errorStatus THEN
	state:=10;
END_IF

//update HMI with certain motor values. 
hmi_update();



//-------------------------------------------------------------------------------------------------------------- MOTOR CONTROL --------------------------------------------------------------------------------------------------------------
CASE state OF
	00: //INIT STATE
	
	tstart:=TIME();
	state:=10;
	// ========================================10========================================
	10: //STANDBY STATE. 
	//wait for user inputs to transition to tension state. All motors are idle. Can edit params
	
	stop_all();
	// ========================================20========================================
	20: //STANDBY WITH STANDSTILL TENSION INITAL
	//inital error check for standstill tension state
	
	count_enabled_motors();
	//check inputs for standstill tension
	IF standstill_tension_check() THEN
		//if error then revert to standby
		state:=10;
		hmiConnection^.tensionUI:=FALSE;
	ELSE
		state:=21;
		
	END_IF
	// ========================================20========================================
	
	// ========================================21========================================
	21://STANDBY WITH STANDSTILL TENSION
	//no movement in cable, but tension is being created. waiting on user inputs to start winding. Can edit params
	
	
	standstill_tension();
	// ========================================21========================================

	// ========================================30========================================
	30: //WINDING TENSION INITAL
	//inital error check for winding tension state.
	
	count_enabled_motors();
	// INPUT VALIDATION
	IF winding_check() THEN
		//if error then revert to standby
		state:=20;
		hmiConnection^.startUI:=FALSE;
		
		
		
	ELSE
		eventLogger^.fbMessage[1].Send(0);
		state:=31;
		tStart:=TIME();
	END_IF
	// ========================================30========================================
	
	// ========================================31========================================
	31: //WINDING TENSION, ACCELERATION
	//coil is currently ramping speed. can not edit params.
	
	

	
	accelerating_tension();
	determine_motor_state();
	tElapsed:=TIME() -tStart;
	
	IF winding_exit_check() THEN
	
		state:=39;
		
	ELSE
		state:=31;
	END_IF
	
	
	// ========================================31========================================
	
	// ========================================32========================================
	32: //WINDING TENSION, STEADY STATE
	//coil is in steady state. moving at constant velo with set tension. Can not edit params
	
	
	
	winding_tension();
	determine_motor_state();
	tElapsed:=TIME() -tStart;

	//check for exit conditions 
	IF winding_exit_check() THEN
		
		state:=39;
		
	ELSE
		state:=32;
	END_IF
	
	
	
	// ========================================32========================================
	
	// ========================================33========================================
	33: //WINDING TENSION, DEACCELERATION
	//coil currently decreasing speed, while maintaining. Can not edit params
	

	
	decelerating_tension();
	determine_motor_state();
	tElapsed:=TIME() -tStart;

	//check for exit conditions 
	IF winding_exit_check() THEN
		
		state:=39;
		
	ELSE
		state:=33;
	END_IF
	// ========================================33========================================
	
	// ========================================39========================================
	39: // transition state from winding => finished
		eventLogger^.fbMessage[2].Send(0);
		hmiConnection^.startUI:=FALSE;
		
		tEnd:=TIME();
		tElapsed:=tEnd -Tstart;
		
		fileReadWrite^.update_database(user:= 'TO DO figure out how to get user information',
										timeStarted:=tStart,
										timeCompleted:=tEnd,
										timeElasped:=tElapsed,
										numOfCoil:=numOfEnabledPayoff,
										lengthOCoil:=find_tape_length_used(),
										userNote:=hmiConnection^.userNote);
		fileReadWrite^.bInitWrite:=TRUE;			
		
	
		state:=40;
	// ========================================39========================================
	
	
	// ========================================40========================================
	40: //FINISHED HOLD STANDSTILL TENSION
	//cable winding finished, currently mainting tension until user input. Can not edit params
	
	standstill_tension();
	
	IF standstill_tension_check() THEN
		//if error then revert to standby
		state:=51;
		
	ELSE
		state:=40;
		
	END_IF
	// ========================================40========================================
	
	// ========================================41========================================
	41: //FINISHED NO TENSION
	//cable winding finished, waiting on user reset to transition to standby state. Can edit params
	//do not control tension
	
	// ========================================41========================================
	

	// ========================================50========================================
	50:
	//exit homing state if homing is done or error.
	IF set_pos_all() THEN
		state:=10;
		hmiConnection^.homeUI:=FALSE;
	
	ELSE
		state:=50;
	END_IF
	
	
	
	
	
	// ========================================50========================================
	
	// ========================================60========================================
	60:
	//exit homing state if homing is done or error.
	IF Home() THEN
		state:=10;
		hmiConnection^.homeUI:=FALSE;
	
	ELSE
		state:=50;
	END_IF
	
	
	// ========================================60========================================
	
	
	400: //ERROR STATE
	//error on a axis preventing motor movement, or winding start. //do nothing 'till resolved
	500: //ESTOP STATE
	//triggered on estop press. can be cleared with reset
		estop_routine();
		
	
END_CASE
//-------------------------------------------------------------------------------------------------------------- MOTOR CONTROL --------------------------------------------------------------------------------------------------------------

//get status updates
//only calculate once very N turns in order to save resources. there also shouldnt be need to run eveyr plc cycle
	
IF (cnt MOD 10 =0) and  NOT(desiredLinspeed = 0) THEN
	etaFormattedString:=find_eta();
	progressPercent :=get_current_progress();
END_IF


//Call cyclic methods of all axies 
pickup_axis_list[1].CYLIC();

FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	payoff_axis_list[i].CYLIC();
END_FOR


]]></ST>
      </Implementation>
    </Method>
    <Method Name="decelerating_tension" Id="{c76da513-9eeb-4494-921e-e9d30e1467af}" FolderPath="Methods\Motor Control\">
      <Declaration><![CDATA[METHOD decelerating_tension : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="determine_motor_state" Id="{e8b4b006-30e0-4934-923d-a97aac10b32d}" FolderPath="Methods\Motor Control\">
      <Declaration><![CDATA[METHOD determine_motor_state : BOOL
VAR_INPUT
END_VAR





VAR
	actualLinspeed : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//to do . comeback on this and do a once over. not sure if this is what we want.
			
actualLinspeed:=pickup_axis_list[1].getDistToAxis()*pickup_axis_list[1].actualVelocity/57.29578;
		
//if we are below our desired
IF actualLinspeed <= 0.9*desiredLinspeed THEN
	
	state:=31;

//last turn dedicated to decelerating 
ELSIF pickup_axis_list[1].AXIS.NcToPlc.ModuloActTurns = desiredTurnCountPickup-1 THEN

	state:=33;

//if not accelerating or decelerating then we are in steady state
ELSE

	state:=32;
	
END_IF

 
	
	


]]></ST>
      </Implementation>
    </Method>
    <Method Name="estop_routine" Id="{e370fdf5-060a-481a-8925-f8c00351b401}" FolderPath="Methods\Motor Control\">
      <Declaration><![CDATA[METHOD estop_routine : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//during estop, cut power to motors.

//turn power off on all axies. 
pickup_axis_list[1].MCPOWER(Axis:=pickup_axis_list[1].AXIS,ENABLE:=FALSE);

FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
		payoff_axis_list[i].MCPOWER(Axis:=payoff_axis_list[i].AXIS,ENABLE:=FALSE);
END_FOR
	
			
	











]]></ST>
      </Implementation>
    </Method>
    <Method Name="find_eta" Id="{85e42879-e4fd-44ad-b45f-475c7a661596}" FolderPath="Methods\Status Updates\">
      <Declaration><![CDATA[//updates eta var
METHOD find_eta : STRING(255)
VAR
	length : LREAL; //length of straight sections in race track coil
	minutes: DINT;
	
	seconds: DINT;
	minutesString: STRING;
	secondsString: STRING;
	formattedString: STRING(255);
	tape_thicnes: LREAL :=0; //total tape thickness in meters
	i: INT;
	total_circum: LREAL;
	currentTurnCount: LREAL;
	currentCircum: LREAL;
END_VAR
VAR CONSTANT
	pi : LREAL := 4 * ATAN(1);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//if we are finished out put 0 seconds and exit
IF state <=59 AND state >= 50 THEN
eta:=0;
RETURN ;
END_IF

CASE pickup_axis_list[1].coilShapeID OF
	//finds eta given turn count
	//formulas are a function of circumfrence given turn count. we take the intergral of this, with respect to turn count, with the upper bound being our target turn count 
	0:
	
	tape_thicnes:=0;
	FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
		IF payoff_axis_list[i].enabled THEN
		tape_thicnes:=tape_thicnes+payoff_axis_list[i].tape_info[payoff_axis_list[i].tapeType].tape_depth/1000;
		END_IF
	END_FOR
	

	
	
	
	total_circum:=2*pi*desiredTurnCountPickup*pickup_axis_list[1].pancake.radius/1000 + tape_thicnes*EXPT(desiredTurnCountPickup,2)*pi;
	
	currentTurnCount:=pickup_axis_list[1].AXIS.NcToPlc.ModuloActPos/360+pickup_axis_list[1].AXIS.NcToPlc.ModuloActTurns;
	
	currentCircum:=2*pi*currentTurnCount*pickup_axis_list[1].pancake.radius/1000 +tape_thicnes*EXPT(currentTurnCount,2)*pi;
	
	IF NOT(desiredLinspeed =0) THEN
		eta:=(total_circum-currentCircum)/desiredLinspeed;
	ELSE
		eta:=0;
	END_IF
	

	
	
	
	1:	
	// to do. update this monster of a formula for the race track coil. derived through calculus, which is probably correct, just now cant figure it out because i decided to write a one liner instead of splitting up
	(*
	eta:=((2*pi*racetrack_params.radius*target_turn_count_pickup+pi*tape_info.tape_depth*target_turn_count_pickup*target_turn_count_pickup+2*racetrack_params.length*target_turn_count_pickup)
		 -(2*pi*racetrack_params.radius*pickup_motor_list[1].turn_count+pi*tape_info.tape_depth*target_turn_count_pickup*pickup_motor_list[1].turn_count+2*racetrack_params.length*pickup_motor_list[1].turn_count));
		 *)
END_CASE


// Convert the LREAL value to minutes and seconds
minutes := TRUNC(eta / 60);
seconds := TRUNC(eta - (minutes * 60));

// Convert the minutes and seconds to strings
minutesString := DINT_TO_STRING(minutes);
secondsString := DINT_TO_STRING(seconds);

// Format the final output string
find_eta := CONCAT(CONCAT('ETA: ', minutesString), CONCAT(':', secondsString));
]]></ST>
      </Implementation>
    </Method>
    <Method Name="find_tape_length_used" Id="{7ea290bf-df4e-4690-9fae-b92992bd262d}" FolderPath="Methods\Status Updates\">
      <Declaration><![CDATA[METHOD find_tape_length_used : LREAL
VAR_INPUT
END_VAR

VAR
	tape_thicnes: LREAL;
	i: INT;
	total_circum: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//TO DO not sure how acurate this. i sort of stole this code from another function.

CASE pickup_axis_list[1].coilShapeID OF
	//finds eta given turn count
	//formulas are a function of circumfrence given turn count. we take the intergral of this, with respect to turn count, with the upper bound being our target turn count 
	0:
	
	tape_thicnes:=0;
	FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
		IF payoff_axis_list[i].enabled THEN
		tape_thicnes:=tape_thicnes+payoff_axis_list[i].tape_info[payoff_axis_list[i].tapeType].tape_depth/1000;
		END_IF
	END_FOR
	

	
	
	
	total_circum:=2*pi*desiredTurnCountPickup*pickup_axis_list[1].pancake.radius/1000 + tape_thicnes*EXPT(desiredTurnCountPickup,2)*pi;
	
	
	

	
	
	
	1:	
	// to do. update this monster of a formula for the race track coil. derived through calculus, which is probably correct, just now cant figure it out because i decided to write a one liner instead of splitting up
	(*
	eta:=((2*pi*racetrack_params.radius*target_turn_count_pickup+pi*tape_info.tape_depth*target_turn_count_pickup*target_turn_count_pickup+2*racetrack_params.length*target_turn_count_pickup)
		 -(2*pi*racetrack_params.radius*pickup_motor_list[1].turn_count+pi*tape_info.tape_depth*target_turn_count_pickup*pickup_motor_list[1].turn_count+2*racetrack_params.length*pickup_motor_list[1].turn_count));
		 *)
END_CASE



find_tape_length_used:=total_circum;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="general_error_check" Id="{8ba42383-7e8f-4747-9137-d6b0ee74634e}" FolderPath="Methods\Error Checks\">
      <Declaration><![CDATA[METHOD general_error_check : BOOL
VAR
	i: INT;
	pickup_motor_count: INT;
	adsError : BOOL;
END_VAR
VAR_OUTPUT
	errorStatus : BOOL ;
END_VAR
VAR_IN_OUT
	errorOutput: BOOL ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Checks to see if there are any errors in a enabled axis.


pickup_axis_list[1].error_check_all();

errorStatus:=pickup_axis_list[1].AXIS.Status.Error OR pickup_axis_list[1].adsError ;
		
IF errorOutput AND pickup_axis_list[1].AXIS.Status.Error THEN
			
			ADSLOGSTR(
        		msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        		msgFmtStr := 'Error occurred. Error on Pickup Axis with ID: %S',
        		strArg := UDINT_TO_STRING(pickup_axis_list[1].AXIS.Status.ErrorID)
   			 );
		
			errorOutput:=FALSE;
		
END_IF
		
IF errorOutput AND pickup_axis_list[1].adsError THEN
			
			ADSLOGSTR(
        		msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        		msgFmtStr := 'Error occurred. Error in Pickup Axis FB with ID: %S ',
        		strArg := UDINT_TO_STRING(pickup_axis_list[1].adsErrorID)
   			 );
		
			errorOutput:=FALSE;
		
END_IF



FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	
	payoff_axis_list[i].error_check_all();

	
		errorStatus:=errorStatus OR ((payoff_axis_list[i].AXIS.Status.Error OR payoff_axis_list[i].adsError) AND payoff_axis_list[i].enabled);
		
		IF errorOutput AND payoff_axis_list[i].AXIS.Status.Error THEN
			
			ADSLOGSTR(
        		msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        		msgFmtStr := 'Error occurred. Error on Pickup Axis with ID: %S',
        		strArg := UDINT_TO_STRING(payoff_axis_list[i].AXIS.Status.ErrorID)
   			 );
		
			errorOutput:=FALSE;
		
END_IF
		
IF errorOutput AND payoff_axis_list[i].adsError THEN
			
			ADSLOGSTR(
        		msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        		msgFmtStr := 'Error occurred. Error in Pickup Axis FB with ID: %S ',
        		strArg := UDINT_TO_STRING(payoff_axis_list[i].adsErrorID)
   			 );
		
			errorOutput:=FALSE;
		
END_IF
		
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="general_input_check" Id="{a3d14995-b6bb-4412-80c9-b4d7fa9675b0}" FolderPath="Methods\Input Checks\">
      <Declaration><![CDATA[METHOD general_input_check : BOOL
VAR_INPUT
	write: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF hmiConnection^.general_input_datagrid_params_list[1].tension < input_bounds.tension_low OR hmiConnection^.general_input_datagrid_params_list[1].tension > input_bounds.tension_high THEN
	general_input_check := TRUE;
	
	ADSLOGSTR(
        	msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        	msgFmtStr := 'Error occurred. Tension outside of range. ',
        	strArg := ''
   		 );
	
ELSE
	
	IF write THEN
		desiredTension:=hmiConnection^.general_input_datagrid_params_list[1].tension;
	
	END_IF
END_IF

IF hmiConnection^.general_input_datagrid_params_list[1].linspeed < input_bounds.linear_speed_low OR hmiConnection^.general_input_datagrid_params_list[1].linspeed > input_bounds.linear_speed_high THEN
	general_input_check := TRUE;
	
	ADSLOGSTR(
        	msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        	msgFmtStr := 'Error occurred. Linear speedc out of range.',
        	strArg := ''
   		 );
	
ELSE
	IF write THEN
		desiredLinspeed:=hmiConnection^.general_input_datagrid_params_list[1].linspeed;
	
	END_IF
	
END_IF

IF write THEN
	unwinding:=hmiConnection^.general_input_datagrid_params_list[1].unwinding;
	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="get_current_progress" Id="{504eb237-53a6-4e39-b7e7-217f0cf72225}" FolderPath="Methods\Status Updates\">
      <Declaration><![CDATA[METHOD get_current_progress : LREAL


]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF unwinding THEN
	get_current_progress := 100-(pickup_axis_list[1].AXIS.NcToPlc.ModuloActTurns/desiredTurnCountPickup)*100;
	
ELSE
	get_current_progress := ((pickup_axis_list[1].AXIS.NcToPlc.ModuloActPos/360+pickup_axis_list[1].AXIS.NcToPlc.ModuloActTurns)/desiredTurnCountPickup)*100;

END_IF
	

	]]></ST>
      </Implementation>
    </Method>
    <Method Name="hmi_update" Id="{15a1114f-a0f7-4eca-8f18-4cf797395fba}" FolderPath="Methods\HMI updates\">
      <Declaration><![CDATA[METHOD hmi_update : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//collection of functions to update hmi vars. 

hmiConnection^.state:=state;

update_error_status();
update_torque();
update_velocity();



hmiConnection^.overview_outputs_datagrid_list[1].pickupTurnCount:=pickup_axis_list[1].AXIS.NcToPlc.ModuloActPos/360+pickup_axis_list[1].AXIS.NcToPlc.ModuloActTurns;
hmiConnection^.overview_outputs_datagrid_list[1].linspeed:=pickup_axis_list[1].actualVelocity*payoff_axis_list[1].getDistToAxis()/57.29578;
hmiConnection^.overview_outputs_datagrid_list[1].torque:=pickup_axis_list[1].actualTorque/pickup_axis_list[1].getDistToAxis();

hmiConnection^.turncount_output_datagrid_list[1].pickupTC1:=pickup_axis_list[1].AXIS.NcToPlc.ModuloActPos/360+pickup_axis_list[1].AXIS.NcToPlc.ModuloActTurns;
hmiConnection^.turncount_output_datagrid_list[1].payoffTC1:=payoff_axis_list[1].AXIS.NcToPlc.ModuloActPos/360+payoff_axis_list[1].AXIS.NcToPlc.ModuloActTurns;
hmiConnection^.turncount_output_datagrid_list[1].payoffTC2:=payoff_axis_list[2].AXIS.NcToPlc.ModuloActPos/360+payoff_axis_list[2].AXIS.NcToPlc.ModuloActTurns;
hmiConnection^.turncount_output_datagrid_list[1].payoffTC3:=payoff_axis_list[3].AXIS.NcToPlc.ModuloActPos/360+payoff_axis_list[3].AXIS.NcToPlc.ModuloActTurns;]]></ST>
      </Implementation>
    </Method>
    <Method Name="home" Id="{e2c62351-b82f-409f-8c6d-bb5032e701a1}" FolderPath="Methods\Motor Control\">
      <Declaration><![CDATA[METHOD home : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
	busytemp: BOOL;
	errortemp: BOOL;
	busy: INT;
	error: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//inital jog (so function not closed right away) 

	FOR i:=1 TO GVL.MAX_PAYOFF_COUNT+GVL.MAX_PICKUP_COUNT DO
		IF axis_list[i].enabled THEN
			
			axis_list[i].MCJOG(,eAcceleration:=axis_list[i].acceleration,mode:=MC_JOGMODE_STANDARD_SLOW,Position:=0,Deceleration:=axis_list[i].deceleration,Velocity:=180,axis:=AXIS_LIST[i]);
			
		END_IF
	END_FOR 


	FOR i:=1 TO GVL.MAX_PAYOFF_COUNT+GVL.MAX_PICKUP_COUNT DO
		IF axis_list[i].enabled THEN
			
			axis_list[i].jogEnable:=TRUE;	
			home := home AND NOT axis_list[i].MCJOG.Busy;
		END_IF
	END_FOR 












]]></ST>
      </Implementation>
    </Method>
    <Method Name="INIT" Id="{a56443b6-9d3c-4e19-bf68-551e95d54fd0}">
      <Declaration><![CDATA[METHOD INIT : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[init_coil_model();
//Call cyclic methods of all axies 

pickup_axis_list[1].INIT();

pickup_axis_list[1].torqaueConstrant:=GVL.PICKUP_TORQUE_CONSTANT;
pickup_axis_list[1].ratedCurrent:=GVL.PICKUP_RATED_CURRENT;
pickup_axis_list[1].enabled:=TRUE;

pickup_axis_list[1].gearRatioNum:=10;
pickup_axis_list[1].gearRatioDen:=1;
FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	payoff_axis_list[i].INIT();
	payoff_axis_list[i].torqaueConstrant:=GVL.PAYOFF_TORQUE_CONSTANT;
	payoff_axis_list[i].ratedCurrent:=GVL.PAYOFF_RATED_CURRENT;
	payoff_axis_list[i].gearRatioNum:=60;
	payoff_axis_list[i].gearRatioDen:=1;
END_FOR

etaFormattedString := CONCAT(CONCAT('ETA: ', '0'), CONCAT(':', '0'));


axis_list[1]:=ADR(pickup_axis_list[1]);
axis_list[2]:=ADR(payoff_axis_list[1]);
axis_list[3]:=ADR(payoff_axis_list[2]);
axis_list[4]:=ADR(payoff_axis_list[3]);]]></ST>
      </Implementation>
    </Method>
    <Method Name="init_coil_model" Id="{90edf354-a001-4a69-9922-1b60f25b1548}" FolderPath="Methods\Init Methods\">
      <Declaration><![CDATA[METHOD init_coil_model : BOOL
VAR 
	med_val : LREAL; // intermediate value 
	i :INT ;
	
	coil_type: INT:=0;
	cnt: INT :=0; //temp
END_VAR
VAR CONSTANT
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//TO DO this funciton was orginall made to create a model of a non circular pickup coil shape. i would like to redo it. 

(*



	//1:
	//creates 1205 points to model a race track coil. we do this 
	cnt:=0;
	FOR i := -150 TO 150 DO
    	coil_model_base_Xcords[1][i+151]:=racetrack_params_1.radius+pickup_motor_list[1].turn_count*tape_info.tape_depth;
		coil_model_base_Ycords[1][i+151]:=i;
		
		
	END_FOR;
	FOR i := -150 TO 150 DO
    	coil_model_base_Xcords[1][i+452]:=-(coil_shape_params.radius+pickup_motor_list[1].turn_count*tape_info.tape_depth);
		coil_model_base_Ycords[1][i+452]:=i;
	
	END_FOR;
	FOR i := -150 TO 150 DO
		med_val:=(pi/300)*i+pi;
		
		
    	coil_model_base_Xcords[1][i+753]:=(coil_shape_params.radius+pickup_motor_list[1].turn_count*tape_info.tape_depth)*SIN(med_val);
		coil_model_base_Ycords[1][i+753]:=-1*coil_shape_params.length*COS(med_val);
	
	END_FOR;
	FOR i := -150 TO 150 DO
		med_val:=(pi/300)*i;
		
		
    	coil_model_base_Xcords[1][i+904]:=(coil_shape_params.radius+pickup_motor_list[1].turn_count*tape_info.tape_depth)*SIN(med_val);
		coil_model_base_Ycords[1][i+904]:=coil_shape_params.length*COS(med_val);
	
	END_FOR;
	 
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="input_update" Id="{a62c6a9d-53f4-4e3a-966f-6f249a814bd7}" FolderPath="Methods\Input Checks\">
      <Declaration><![CDATA[METHOD input_update : BOOL
VAR_INPUT
	general : BOOL ;
	pickup : BOOL ;
	payoff : BOOL ;
END_VAR



VAR
	
	//chooses which inputs we will update.         
	i: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//NOT NEEDED ANYMORE
(*


//Updates internal winding control variables with HMI inputs. 
IF pickup THEN
	pickup_axis_list[1].coilShapeID:=hmiConnection^.pickup_input_datagrid_params_list[1].coil_shape;
	desiredTurnCountPickup:=hmiConnection^.pickup_input_datagrid_params_list[1].turn_count;
END_IF

IF payoff THEN
	FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
		payoff_axis_list[i].enabled:=hmiConnection^.payoff_input_datagrid_params_list[i].enabled;
	IF payoff_axis_list[i].enabled THEN
		payoff_axis_list[i].pancake.radius:=hmiConnection^.payoff_input_datagrid_params_list[i].outer_dia;
		
	
	END_IF
	
	END_FOR
END_IF

IF general THEN
	desiredLinspeed:=hmiConnection^.general_input_datagrid_params_list[1].linspeed;
	desiredTension:=hmiConnection^.general_input_datagrid_params_list[1].tension;
	unwinding:=hmiConnection^.general_input_datagrid_params_list[1].unwinding;
	
	pickup_axis_list[1].directionB:=BOOL_TO_INT(unwinding);
	
	FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
		payoff_axis_list[i].directionB:=BOOL_TO_INT(unwinding);

	END_FOR
END_IF

*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="payoff_input_check" Id="{70c3f949-5037-419d-bccb-87705ebd3434}" FolderPath="Methods\Input Checks\">
      <Declaration><![CDATA[METHOD payoff_input_check : BOOL
VAR_INPUT
END_VAR

VAR_input
	write: BOOL;
END_VAR
VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[ FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	
	IF write THEN
		payoff_axis_list[i].enabled:=hmiConnection^.payoff_input_datagrid_params_list[i].enabled;
		payoff_axis_list[i].tapeType:=hmiConnection^.payoff_input_datagrid_params_list[i].tape_type;
	END_IF

	IF hmiConnection^.payoff_input_datagrid_params_list[i].enabled THEN
		
	
		IF hmiConnection^.payoff_input_datagrid_params_list[i].radius < input_bounds.radius_payoff_low OR hmiConnection^.payoff_input_datagrid_params_list[i].radius > input_bounds.radius_payoff_high THEN
		payoff_input_check := TRUE;
	
		ADSLOGSTR(
        	msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        	msgFmtStr := 'Error occurred. Payoff Radius outside of range.',
        	strArg := ''
   		 );
		
		ELSE 
			IF write THEN
				payoff_axis_list[i].pancake.radius:=hmiConnection^.payoff_input_datagrid_params_list[i].radius;
			END_IF
		END_IF
	
	END_IF
	
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="pickup_input_check" Id="{3a472a75-4ad8-4147-bca7-de8a29e62be5}" FolderPath="Methods\Input Checks\">
      <Declaration><![CDATA[METHOD pickup_input_check : BOOL
VAR_INPUT
	write : BOOL ;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF hmiConnection^.pickup_input_datagrid_params_list[1].turn_count < input_bounds.turn_count_pickup_low OR hmiConnection^.pickup_input_datagrid_params_list[1].turn_count > input_bounds.turn_count_pickup_high THEN
	pickup_input_check := TRUE;
	
	ADSLOGSTR(
        	msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        	msgFmtStr := 'Error occurred. Pickup turncount outside of range.',
        	strArg := ''
   		 );
	
ELSE
	
	IF write THEN
		desiredTurnCountPickup:=hmiConnection^.pickup_input_datagrid_params_list[1].turn_count;
	END_IF

	
	
	
END_IF


]]></ST>
      </Implementation>
    </Method>
    <Method Name="read_status" Id="{c26500a1-9771-4061-a160-1627c7f00ff3}" FolderPath="Methods\Axis Control\">
      <Declaration><![CDATA[METHOD read_status : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[ //updates status of all axises, pickup and payoff

pickup_axis_list[1].Axis.ReadStatus();


FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	payoff_axis_list[i].AXIS.ReadStatus();
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="reset" Id="{aef7dc8a-f8b9-41a2-9568-128920b7af80}" FolderPath="Methods\MISC\">
      <Declaration><![CDATA[METHOD reset : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[state := 10;
progressPercent:=0;

fileReadWrite^.reset();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="set_pos_all" Id="{dae62719-33d8-49b6-8821-ff4d77998180}" FolderPath="Methods\Motor Control\">
      <Declaration><![CDATA[METHOD set_pos_all : BOOL
VAR_INPUT
END_VAR

VAR

	i: INT;
	busy : BOOL :=FALSE;
	busytemp : BOOL := FALSE;
	error : BOOL:= FALSE;
	errorTemp : BOOL := FALSE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//to do . bug where after a failed winding attemp, users need to press button one more time inorder for command to run. coming back to this later

//function to set pos of all motors to 0

//turn power off on all axies. need for set pos function
pickup_axis_list[1].MCPOWER(Axis:=pickup_axis_list[1].AXIS,ENABLE:=FALSE);

FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
	IF payoff_axis_list[i].enabled THEN
			
		payoff_axis_list[i].MCPOWER(Axis:=payoff_axis_list[i].AXIS,ENABLE:=FALSE);
	END_IF
END_FOR 




//set pos, repeat till not busy. 
REPEAT
	
	//set pos of pickup
	pickup_axis_list[1].MCPOS(Axis:=pickup_axis_list[1].Axis,Execute:=TRUE,Position:=0,MODE:=FALSE,busy=>busytemp,Error=>errortemp);
	busy:= busy AND busytemp;
	error:= error AND errorTemp;


//set pos of payoff
	FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
		IF payoff_axis_list[i].enabled THEN
			
			payoff_axis_list[1].MCPOS(Axis:=payoff_axis_list[1].Axis,Execute:=TRUE,Position:=0,MODE:=FALSE,busy=>busytemp,Error=>errortemp);
			busy:=busy AND busytemp;
			error:= error AND errorTemp;
		END_IF
	END_FOR 


//exit condition	
UNTIL 
//exit when all axies are no longer busy
NOT BUSY
END_REPEAT

pickup_axis_list[1].MCPOS(Axis:=pickup_axis_list[1].Axis, Execute:=TRUE,Position:=0,mode:=FALSE);


set_pos_all:=TRUE;

//turn power off on all axies. 
pickup_axis_list[1].MCPOWER(Axis:=pickup_axis_list[1].AXIS,ENABLE:=TRUE);
pickup_axis_list[1].MCPOS(Axis:=pickup_axis_list[1].Axis,Execute:=FALSE,Position:=0,MODE:=FALSE,busy=>busytemp,Error=>errortemp);

FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
	IF payoff_axis_list[i].enabled THEN
		payoff_axis_list[i].MCPOWER(Axis:=payoff_axis_list[i].AXIS,ENABLE:=TRUE);
		payoff_axis_list[i].MCPOS(Axis:=payoff_axis_list[1].Axis,Execute:=FALSE,Position:=0,MODE:=FALSE,busy=>busytemp,Error=>errortemp);
	END_IF		
END_FOR 








]]></ST>
      </Implementation>
    </Method>
    <Method Name="standstill_tension" Id="{2810c0a6-5d8e-4e25-8bef-5c7267116cff}" FolderPath="Methods\Motor Control\">
      <Declaration><![CDATA[METHOD standstill_tension : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//creates tension in tape, but does not move the tape.

//set torque to force times number of payoff motors enabled. 
pickup_axis_list[1].torque:=(desiredTension*numOfEnabledPayoff*	pickup_axis_list[1].getDistToAxis())/2;
	
//TO DO need to find what to set these to. might be too low. 
pickup_axis_list[1].velocityLimitLow:=0;
pickup_axis_list[1].velocityLimitHigh:=1;
	
	
pickup_axis_list[1].setTorque();
	
	
FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
	IF payoff_axis_list[i].enabled THEN
		payoff_axis_list[i].setTorque();
		
		payoff_axis_list[1].velocityLimitLow:=0;
		payoff_axis_list[1].velocityLimitHigh:=1;
		payoff_axis_list[i].torque:=-1*desiredTension*	payoff_axis_list[1].getDistToAxis()/2;
			
	END_IF
END_FOR 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="standstill_tension_check" Id="{4514199c-9af5-4a98-ad75-0298298ebf12}" FolderPath="Methods\Input Checks\">
      <Declaration><![CDATA[METHOD standstill_tension_check : BOOL
VAR_OUTPUT

END_VAR
VAR
	input_bounds : input_bounds; //struct defining input bounds
	i: INT; //counter
	
	
	payoffEnableCheck :BOOL :=FALSE; //var to hold payoff enable var
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//check to see if HMI vars are valid for stand still tension before winding. outputs true if there was an error.

//PICKUP AXIS CHECKS

IF hmiConnection^.general_input_datagrid_params_list[1].tension < input_bounds.tension_low OR hmiConnection^.general_input_datagrid_params_list[1].tension > input_bounds.tension_high THEN
	standstill_tension_check := TRUE;
	
	ADSLOGSTR(
        	msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        	msgFmtStr := 'Error occurred. Tension outside of range. Unable to start tension',
        	strArg := ''
   		 );
	
ELSE
	desiredTension:=hmiConnection^.general_input_datagrid_params_list[1].tension;
	
END_IF

//PAYOFF AXIS CHECKS

FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	payoffEnableCheck:=payoffEnableCheck OR hmiConnection^.payoff_input_datagrid_params_list[i].enabled;
	
END_FOR


IF NOT payoffEnableCheck THEN
	standstill_tension_check := TRUE;
	
	ADSLOGSTR(
        	msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        	msgFmtStr := 'Error occurred. At least one payoff motor needs to be enabled',
        	strArg := ''
   		 );

END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="stop_all" Id="{91a32785-37fe-490f-8e36-a7fa897334e3}" FolderPath="Methods\Motor Control\">
      <Declaration><![CDATA[METHOD stop_all : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
	pickup_axis_list[1].setStop();
		
	FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
		
			payoff_axis_list[i].setStop();
			
		
	END_FOR 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="transfer_hmi_vars" Id="{a22def73-99d5-4798-8700-74bd55b9eec0}" FolderPath="Methods\MISC\">
      <Declaration><![CDATA[METHOD transfer_hmi_vars : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//transfer vars from hmi to windingcontrol

//general
desiredTension:=hmiConnection^.general_input_datagrid_params_list[1].tension;

desiredLinspeed:=hmiConnection^.general_input_datagrid_params_list[1].linspeed;

unwinding:=hmiConnection^.general_input_datagrid_params_list[1].unwinding;

//pickup

desiredTurnCountPickup:=hmiConnection^.pickup_input_datagrid_params_list[1].turn_count;
pickup_axis_list[1].coilShapeID:=hmiConnection^.pickup_input_datagrid_params_list[1].coil_shape;
pickup_axis_list[1].pancake.radius:=hmiConnection^.pickup_pancake_input_datagrid_params_list[1].radius;
//payoff
 FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	

	payoff_axis_list[i].enabled:=hmiConnection^.payoff_input_datagrid_params_list[i].enabled;
	payoff_axis_list[i].tapeType:=hmiConnection^.payoff_input_datagrid_params_list[i].tape_type;
	
	payoff_axis_list[i].pancake.radius:=hmiConnection^.payoff_input_datagrid_params_list[i].radius;
		
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="update_error_status" Id="{8a130ded-d455-41f2-ac7c-8c70dbeb7a89}" FolderPath="Methods\HMI updates\">
      <Declaration><![CDATA[METHOD update_error_status : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[hmiConnection^.output_error_datagrid_list[0].errorStatus:=pickup_axis_list[1].AXIS.Status.Error;
hmiConnection^.output_error_datagrid_list[0].errorID:=pickup_axis_list[1].AXIS.Status.ErrorID;

hmiConnection^.motor_state_datagrid_list[0].state:=pickup_axis_list[1].state;

FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	hmiConnection^.output_error_datagrid_list[i].errorStatus:=payoff_axis_list[i].AXIS.Status.Error;
	hmiConnection^.output_error_datagrid_list[i].errorID:=payoff_axis_list[i].AXIS.Status.ErrorID;
	
	hmiConnection^.motor_state_datagrid_list[i].state:=payoff_axis_list[i].state;
	
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="update_torque" Id="{ea80d7c9-b122-46ba-af4e-b3e883f32cba}" FolderPath="Methods\HMI updates\">
      <Declaration><![CDATA[METHOD update_torque : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//update act ual torque values ofc motors. send these values to HMI

pickup_axis_list[1].getTorque();
hmiConnection^.torque[1]:=pickup_axis_list[1].actualTorque;


FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	payoff_axis_list[i].getTorque();
	hmiConnection^.torque[i+1]:=payoff_axis_list[i].actualTorque;

END_FOR


]]></ST>
      </Implementation>
    </Method>
    <Method Name="update_velocity" Id="{e3d6da1b-3c09-4f36-8e11-85f4c14af595}" FolderPath="Methods\HMI updates\">
      <Declaration><![CDATA[METHOD update_velocity : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//update act ual torque values ofc motors. send these values to HMI


hmiConnection^.rpm[1]:=pickup_axis_list[1].actualVelocity;


FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO

	hmiConnection^.rpm[i+1]:=payoff_axis_list[i].actualVelocity;

END_FOR


]]></ST>
      </Implementation>
    </Method>
    <Method Name="winding_check" Id="{31081dd9-0820-42d0-a9d6-769c3442a1c8}" FolderPath="Methods\Input Checks\">
      <Declaration><![CDATA[METHOD winding_check : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="winding_exit_check" Id="{d54735ba-4782-466e-8281-2700698b8cff}" FolderPath="Methods\Exit Checks\">
      <Declaration><![CDATA[METHOD winding_exit_check : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Checks to see if various conditions are met to exit

//turn count condition.

IF pickup_axis_list[1].AXIS.NcToPlc.ModuloActTurns >= desiredTurnCountPickup THEN
	winding_exit_check :=TRUE;
		
	ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_MSGBOX, msgFmtStr := 'Winding stopped, pickup turn count reached', strArg:= '');
END_IF

//inner radius reached check


]]></ST>
      </Implementation>
    </Method>
    <Method Name="winding_tension" Id="{b4e997d8-0092-4fca-a6b8-7c2e056fe739}" FolderPath="Methods\Motor Control\">
      <Declaration><![CDATA[METHOD winding_tension : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
	
	desiredVelocity : LREAL;
	pickupLinspeed: LREAL;
	adjustedVelocity: LREAL;
	dist: LREAL;
END_VAR
VAR CONSTANT
	PERCENT_DIFFERENCE: LREAL := 1.1;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF unwinding THEN
	//to do update with unwinding feature
	
	//do nothing, not implemneted yet. 
ELSE
	


	pickup_axis_list[1].torque:=desiredTension*numOfEnabledPayoff*	pickup_axis_list[1].getDistToAxis();
	
	//TO DO . need to confirm these are correct
	//how i envison the limits to function is that the pickup side will gradually ramp up speed until we hit the upper velocity limit. we could maybe have no limits and just have only torque control
	//will need testing. 
	pickup_axis_list[1].velocityLimitLow:=0;
	pickup_axis_list[1].velocityLimitHigh:=(desiredLinspeed/pickup_axis_list[1].getDistToAxis())*57.29578 ;
	
	pickup_axis_list[1].setTorque();
	
	pickupLinspeed:=pickup_axis_list[1].AXIS.NcToPlc.ActVelo*	pickup_axis_list[1].getDistToAxis()/57.2957;
	
	
	
	FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
		IF payoff_axis_list[i].enabled THEN
			//ASSUMING CONTINOUS UPDATE LIKE FUNCTION
			//TO DO figure out directions
			
			
			payoff_axis_list[i].setVelocity();
			dist:=payoff_axis_list[i].getDistToAxis();
			
			//find the velocity (degree/s) to acheive our desired linear speed, and the linear speed at pickup motor. 
			desiredVelocity:=(desiredLinspeed/dist)*57.29578;
			adjustedVelocity:=(pickupLinspeed/dist)*57.29578;
			
			
			//sets payoff axis to half way point between target linspeed and the actual linspeed.
			//how i envison this to function, is that while pickup side is at a low speed, the payoff side will also work at a lower speed,
			//which gives the pickup time to catch up in speed. right now i do this by just averaging desired speed and actual speed,
			//this could maybe he handled in a better way, so i will leave a TO DO 
			payoff_axis_list[i].velocity:=(desiredVelocity+adjustedVelocity)/2;
			
			
			
		END_IF
	END_FOR 
END_IF
	
	]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_WindingControl">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.accelerating_tension">
      <LineId Id="6" Count="45" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.all_check">
      <LineId Id="5" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="11" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.count_enabled_motors">
      <LineId Id="6" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="9" Count="3" />
      <LineId Id="17" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.CYCLIC">
      <LineId Id="170" Count="0" />
      <LineId Id="746" Count="0" />
      <LineId Id="182" Count="0" />
      <LineId Id="181" Count="0" />
      <LineId Id="457" Count="0" />
      <LineId Id="284" Count="0" />
      <LineId Id="287" Count="0" />
      <LineId Id="1164" Count="0" />
      <LineId Id="288" Count="1" />
      <LineId Id="331" Count="0" />
      <LineId Id="290" Count="3" />
      <LineId Id="308" Count="0" />
      <LineId Id="304" Count="2" />
      <LineId Id="294" Count="0" />
      <LineId Id="296" Count="1" />
      <LineId Id="961" Count="0" />
      <LineId Id="298" Count="1" />
      <LineId Id="586" Count="0" />
      <LineId Id="463" Count="0" />
      <LineId Id="584" Count="0" />
      <LineId Id="615" Count="0" />
      <LineId Id="618" Count="0" />
      <LineId Id="962" Count="0" />
      <LineId Id="619" Count="0" />
      <LineId Id="616" Count="0" />
      <LineId Id="985" Count="1" />
      <LineId Id="988" Count="0" />
      <LineId Id="987" Count="0" />
      <LineId Id="984" Count="0" />
      <LineId Id="617" Count="0" />
      <LineId Id="286" Count="0" />
      <LineId Id="309" Count="1" />
      <LineId Id="312" Count="0" />
      <LineId Id="333" Count="1" />
      <LineId Id="313" Count="1" />
      <LineId Id="332" Count="0" />
      <LineId Id="315" Count="1" />
      <LineId Id="335" Count="0" />
      <LineId Id="317" Count="0" />
      <LineId Id="321" Count="2" />
      <LineId Id="336" Count="1" />
      <LineId Id="324" Count="1" />
      <LineId Id="963" Count="0" />
      <LineId Id="326" Count="1" />
      <LineId Id="338" Count="0" />
      <LineId Id="473" Count="0" />
      <LineId Id="620" Count="0" />
      <LineId Id="622" Count="0" />
      <LineId Id="624" Count="2" />
      <LineId Id="623" Count="0" />
      <LineId Id="621" Count="0" />
      <LineId Id="989" Count="0" />
      <LineId Id="991" Count="2" />
      <LineId Id="990" Count="0" />
      <LineId Id="474" Count="0" />
      <LineId Id="311" Count="0" />
      <LineId Id="339" Count="1" />
      <LineId Id="342" Count="3" />
      <LineId Id="365" Count="2" />
      <LineId Id="346" Count="0" />
      <LineId Id="368" Count="0" />
      <LineId Id="348" Count="9" />
      <LineId Id="369" Count="0" />
      <LineId Id="358" Count="0" />
      <LineId Id="964" Count="0" />
      <LineId Id="359" Count="4" />
      <LineId Id="576" Count="0" />
      <LineId Id="965" Count="0" />
      <LineId Id="364" Count="0" />
      <LineId Id="481" Count="0" />
      <LineId Id="581" Count="0" />
      <LineId Id="483" Count="0" />
      <LineId Id="492" Count="0" />
      <LineId Id="487" Count="1" />
      <LineId Id="482" Count="0" />
      <LineId Id="999" Count="0" />
      <LineId Id="628" Count="4" />
      <LineId Id="627" Count="0" />
      <LineId Id="994" Count="0" />
      <LineId Id="996" Count="2" />
      <LineId Id="995" Count="0" />
      <LineId Id="341" Count="0" />
      <LineId Id="370" Count="0" />
      <LineId Id="404" Count="0" />
      <LineId Id="373" Count="1" />
      <LineId Id="420" Count="7" />
      <LineId Id="375" Count="2" />
      <LineId Id="380" Count="6" />
      <LineId Id="401" Count="2" />
      <LineId Id="387" Count="2" />
      <LineId Id="417" Count="0" />
      <LineId Id="397" Count="2" />
      <LineId Id="577" Count="0" />
      <LineId Id="400" Count="0" />
      <LineId Id="569" Count="0" />
      <LineId Id="580" Count="0" />
      <LineId Id="494" Count="0" />
      <LineId Id="498" Count="1" />
      <LineId Id="501" Count="0" />
      <LineId Id="500" Count="0" />
      <LineId Id="633" Count="0" />
      <LineId Id="635" Count="4" />
      <LineId Id="634" Count="0" />
      <LineId Id="1003" Count="0" />
      <LineId Id="1000" Count="2" />
      <LineId Id="493" Count="0" />
      <LineId Id="372" Count="0" />
      <LineId Id="502" Count="0" />
      <LineId Id="418" Count="1" />
      <LineId Id="435" Count="4" />
      <LineId Id="455" Count="0" />
      <LineId Id="440" Count="14" />
      <LineId Id="428" Count="0" />
      <LineId Id="578" Count="0" />
      <LineId Id="456" Count="0" />
      <LineId Id="570" Count="0" />
      <LineId Id="579" Count="0" />
      <LineId Id="572" Count="3" />
      <LineId Id="571" Count="0" />
      <LineId Id="640" Count="0" />
      <LineId Id="642" Count="4" />
      <LineId Id="641" Count="0" />
      <LineId Id="1004" Count="0" />
      <LineId Id="1006" Count="2" />
      <LineId Id="1005" Count="0" />
      <LineId Id="371" Count="0" />
      <LineId Id="647" Count="0" />
      <LineId Id="695" Count="1" />
      <LineId Id="689" Count="0" />
      <LineId Id="697" Count="2" />
      <LineId Id="693" Count="1" />
      <LineId Id="651" Count="19" />
      <LineId Id="681" Count="2" />
      <LineId Id="686" Count="1" />
      <LineId Id="700" Count="0" />
      <LineId Id="966" Count="0" />
      <LineId Id="688" Count="0" />
      <LineId Id="1009" Count="0" />
      <LineId Id="1011" Count="2" />
      <LineId Id="1010" Count="0" />
      <LineId Id="648" Count="0" />
      <LineId Id="1014" Count="0" />
      <LineId Id="1016" Count="19" />
      <LineId Id="1067" Count="1" />
      <LineId Id="1038" Count="18" />
      <LineId Id="1069" Count="1" />
      <LineId Id="1057" Count="1" />
      <LineId Id="1061" Count="5" />
      <LineId Id="1015" Count="0" />
      <LineId Id="285" Count="0" />
      <LineId Id="458" Count="0" />
      <LineId Id="283" Count="0" />
      <LineId Id="179" Count="1" />
      <LineId Id="523" Count="0" />
      <LineId Id="526" Count="1" />
      <LineId Id="524" Count="0" />
      <LineId Id="528" Count="0" />
      <LineId Id="552" Count="0" />
      <LineId Id="529" Count="1" />
      <LineId Id="830" Count="0" />
      <LineId Id="554" Count="0" />
      <LineId Id="553" Count="0" />
      <LineId Id="534" Count="4" />
      <LineId Id="525" Count="0" />
      <LineId Id="599" Count="0" />
      <LineId Id="598" Count="0" />
      <LineId Id="709" Count="0" />
      <LineId Id="587" Count="1" />
      <LineId Id="522" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="555" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="506" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="516" Count="0" />
      <LineId Id="518" Count="0" />
      <LineId Id="13" Count="1" />
      <LineId Id="203" Count="0" />
      <LineId Id="1077" Count="0" />
      <LineId Id="503" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="57" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="53" Count="3" />
      <LineId Id="52" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="507" Count="1" />
      <LineId Id="44" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="504" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="509" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="1078" Count="0" />
      <LineId Id="215" Count="0" />
      <LineId Id="220" Count="0" />
      <LineId Id="78" Count="3" />
      <LineId Id="890" Count="0" />
      <LineId Id="1089" Count="1" />
      <LineId Id="82" Count="0" />
      <LineId Id="820" Count="0" />
      <LineId Id="83" Count="1" />
      <LineId Id="77" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="513" Count="1" />
      <LineId Id="46" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="224" Count="0" />
      <LineId Id="115" Count="0" />
      <LineId Id="929" Count="1" />
      <LineId Id="919" Count="1" />
      <LineId Id="120" Count="0" />
      <LineId Id="1101" Count="0" />
      <LineId Id="921" Count="0" />
      <LineId Id="924" Count="0" />
      <LineId Id="1129" Count="0" />
      <LineId Id="925" Count="3" />
      <LineId Id="176" Count="0" />
      <LineId Id="519" Count="0" />
      <LineId Id="174" Count="0" />
      <LineId Id="858" Count="0" />
      <LineId Id="833" Count="3" />
      <LineId Id="842" Count="2" />
      <LineId Id="934" Count="0" />
      <LineId Id="845" Count="0" />
      <LineId Id="1102" Count="0" />
      <LineId Id="846" Count="1" />
      <LineId Id="850" Count="0" />
      <LineId Id="1130" Count="0" />
      <LineId Id="851" Count="6" />
      <LineId Id="173" Count="0" />
      <LineId Id="1074" Count="1" />
      <LineId Id="859" Count="2" />
      <LineId Id="938" Count="4" />
      <LineId Id="1103" Count="0" />
      <LineId Id="943" Count="1" />
      <LineId Id="1115" Count="0" />
      <LineId Id="1104" Count="0" />
      <LineId Id="1131" Count="0" />
      <LineId Id="949" Count="1" />
      <LineId Id="879" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="1123" Count="0" />
      <LineId Id="1119" Count="1" />
      <LineId Id="1125" Count="1" />
      <LineId Id="1146" Count="0" />
      <LineId Id="1152" Count="0" />
      <LineId Id="1147" Count="1" />
      <LineId Id="1127" Count="0" />
      <LineId Id="1139" Count="6" />
      <LineId Id="1124" Count="0" />
      <LineId Id="1121" Count="1" />
      <LineId Id="1076" Count="0" />
      <LineId Id="1117" Count="1" />
      <LineId Id="510" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="521" Count="0" />
      <LineId Id="147" Count="6" />
      <LineId Id="125" Count="2" />
      <LineId Id="511" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="1073" Count="0" />
      <LineId Id="512" Count="0" />
      <LineId Id="161" Count="1" />
      <LineId Id="142" Count="1" />
      <LineId Id="603" Count="1" />
      <LineId Id="610" Count="0" />
      <LineId Id="908" Count="0" />
      <LineId Id="612" Count="2" />
      <LineId Id="611" Count="0" />
      <LineId Id="608" Count="1" />
      <LineId Id="605" Count="2" />
      <LineId Id="600" Count="0" />
      <LineId Id="144" Count="0" />
      <LineId Id="1176" Count="11" />
      <LineId Id="1191" Count="0" />
      <LineId Id="145" Count="1" />
      <LineId Id="28" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="42" Count="1" />
      <LineId Id="1071" Count="1" />
      <LineId Id="40" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="515" Count="0" />
      <LineId Id="971" Count="2" />
      <LineId Id="967" Count="3" />
      <LineId Id="541" Count="2" />
      <LineId Id="540" Count="0" />
      <LineId Id="547" Count="4" />
      <LineId Id="545" Count="1" />
      <LineId Id="544" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.decelerating_tension">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.determine_motor_state">
      <LineId Id="14" Count="0" />
      <LineId Id="16" Count="2" />
      <LineId Id="20" Count="1" />
      <LineId Id="33" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="26" Count="1" />
      <LineId Id="37" Count="1" />
      <LineId Id="46" Count="0" />
      <LineId Id="39" Count="1" />
      <LineId Id="45" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="29" Count="1" />
      <LineId Id="28" Count="0" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.estop_routine">
      <LineId Id="8" Count="4" />
      <LineId Id="84" Count="0" />
      <LineId Id="86" Count="1" />
      <LineId Id="85" Count="0" />
      <LineId Id="77" Count="1" />
      <LineId Id="81" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="63" Count="8" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.find_eta">
      <LineId Id="22" Count="9" />
      <LineId Id="74" Count="0" />
      <LineId Id="143" Count="2" />
      <LineId Id="162" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="161" Count="0" />
      <LineId Id="149" Count="11" />
      <LineId Id="181" Count="0" />
      <LineId Id="185" Count="1" />
      <LineId Id="182" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="50" Count="1" />
      <LineId Id="35" Count="1" />
      <LineId Id="52" Count="0" />
      <LineId Id="37" Count="12" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.find_tape_length_used">
      <LineId Id="10" Count="19" />
      <LineId Id="38" Count="14" />
      <LineId Id="61" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.general_error_check">
      <LineId Id="20" Count="0" />
      <LineId Id="66" Count="2" />
      <LineId Id="31" Count="2" />
      <LineId Id="84" Count="9" />
      <LineId Id="22" Count="0" />
      <LineId Id="106" Count="10" />
      <LineId Id="105" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="23" Count="2" />
      <LineId Id="70" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="26" Count="1" />
      <LineId Id="29" Count="0" />
      <LineId Id="117" Count="21" />
      <LineId Id="47" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.general_input_check">
      <LineId Id="6" Count="9" />
      <LineId Id="33" Count="1" />
      <LineId Id="42" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="19" Count="11" />
      <LineId Id="43" Count="2" />
      <LineId Id="31" Count="1" />
      <LineId Id="18" Count="0" />
      <LineId Id="47" Count="3" />
      <LineId Id="46" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.get_current_progress">
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="16" Count="1" />
      <LineId Id="11" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.hmi_update">
      <LineId Id="8" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="5" Count="2" />
      <LineId Id="14" Count="2" />
      <LineId Id="13" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="37" Count="2" />
    </LineIds>
    <LineIds Name="FB_WindingControl.home">
      <LineId Id="92" Count="0" />
      <LineId Id="139" Count="17" />
      <LineId Id="109" Count="2" />
      <LineId Id="124" Count="7" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.INIT">
      <LineId Id="5" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="27" Count="1" />
      <LineId Id="31" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="12" Count="2" />
      <LineId Id="32" Count="1" />
      <LineId Id="30" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="56" Count="1" />
      <LineId Id="55" Count="0" />
      <LineId Id="58" Count="2" />
    </LineIds>
    <LineIds Name="FB_WindingControl.init_coil_model">
      <LineId Id="52" Count="1" />
      <LineId Id="49" Count="2" />
      <LineId Id="16" Count="31" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.input_update">
      <LineId Id="73" Count="3" />
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="35" Count="3" />
      <LineId Id="33" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="24" Count="1" />
      <LineId Id="40" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="43" Count="3" />
      <LineId Id="50" Count="2" />
      <LineId Id="58" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="6" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.payoff_input_check">
      <LineId Id="35" Count="1" />
      <LineId Id="59" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="112" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="60" Count="1" />
      <LineId Id="68" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="77" Count="9" />
      <LineId Id="101" Count="0" />
      <LineId Id="89" Count="1" />
      <LineId Id="102" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="71" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.pickup_input_check">
      <LineId Id="6" Count="9" />
      <LineId Id="34" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="16" Count="4" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.read_status">
      <LineId Id="6" Count="6" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.reset">
      <LineId Id="5" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.set_pos_all">
      <LineId Id="122" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="123" Count="0" />
      <LineId Id="21" Count="3" />
      <LineId Id="52" Count="4" />
      <LineId Id="25" Count="0" />
      <LineId Id="70" Count="3" />
      <LineId Id="26" Count="1" />
      <LineId Id="74" Count="1" />
      <LineId Id="59" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="120" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="64" Count="2" />
      <LineId Id="69" Count="0" />
      <LineId Id="77" Count="1" />
      <LineId Id="68" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="86" Count="1" />
      <LineId Id="30" Count="1" />
      <LineId Id="88" Count="0" />
      <LineId Id="32" Count="1" />
      <LineId Id="93" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="97" Count="3" />
      <LineId Id="116" Count="0" />
      <LineId Id="101" Count="1" />
      <LineId Id="117" Count="0" />
      <LineId Id="119" Count="0" />
      <LineId Id="118" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="82" Count="2" />
      <LineId Id="34" Count="0" />
      <LineId Id="39" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.standstill_tension">
      <LineId Id="23" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="53" Count="11" />
      <LineId Id="73" Count="0" />
      <LineId Id="96" Count="2" />
      <LineId Id="65" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.standstill_tension_check">
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="47" Count="3" />
      <LineId Id="18" Count="2" />
      <LineId Id="25" Count="1" />
      <LineId Id="16" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="57" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="40" Count="1" />
      <LineId Id="39" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="52" Count="3" />
      <LineId Id="51" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="43" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.stop_all">
      <LineId Id="14" Count="0" />
      <LineId Id="20" Count="1" />
      <LineId Id="25" Count="5" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.transfer_hmi_vars">
      <LineId Id="6" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="21" Count="5" />
      <LineId Id="42" Count="1" />
      <LineId Id="20" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.update_error_status">
      <LineId Id="5" Count="1" />
      <LineId Id="35" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="8" Count="1" />
      <LineId Id="12" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="36" Count="1" />
      <LineId Id="27" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.update_torque">
      <LineId Id="6" Count="2" />
      <LineId Id="12" Count="3" />
      <LineId Id="17" Count="1" />
      <LineId Id="29" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="42" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.update_velocity">
      <LineId Id="6" Count="12" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.winding_check">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.winding_exit_check">
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="9" Count="3" />
      <LineId Id="15" Count="1" />
      <LineId Id="21" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.winding_tension">
      <LineId Id="31" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="177" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="69" Count="2" />
      <LineId Id="178" Count="1" />
      <LineId Id="72" Count="4" />
      <LineId Id="121" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="122" Count="1" />
      <LineId Id="77" Count="3" />
      <LineId Id="103" Count="1" />
      <LineId Id="81" Count="1" />
      <LineId Id="162" Count="0" />
      <LineId Id="113" Count="1" />
      <LineId Id="132" Count="0" />
      <LineId Id="115" Count="0" />
      <LineId Id="119" Count="1" />
      <LineId Id="134" Count="0" />
      <LineId Id="180" Count="1" />
      <LineId Id="131" Count="0" />
      <LineId Id="83" Count="3" />
      <LineId Id="67" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="34" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>