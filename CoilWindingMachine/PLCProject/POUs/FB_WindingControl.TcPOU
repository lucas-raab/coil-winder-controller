<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_WindingControl" Id="{2bf4d53e-3c0a-48b3-b562-160f25601b83}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_WindingControl

VAR_INPUT
    // Input connections from MAIN
    hmiConnection   : POINTER TO FB_hmi_connection;   // HMI connection for user interface
    eventLogger     : POINTER TO FB_EventLogger;      // Event logger for system events
    fileReadWrite   : POINTER TO FB_fileReadWrite;    // File read/write operations
END_VAR

VAR
    // =================================== TEMPORARY TESTING VARIABLES ===================================
    dist    : LREAL;    // Distance variable for testing purposes
    testing : BOOL;     // Boolean flag for testing mode

    // ======================================== CONTROL VARIABLES ========================================
    desiredTension          : LREAL := 0;    // Desired tension for winding process
    desiredLinspeed         : LREAL := 0;    // Desired linear speed for winding
    unwinding               : BOOL  := FALSE;// Flag to indicate unwinding operation
    desiredTurnCountPickup  : DINT  := 0;    // Desired turn count for pickup reel
    target_turn_count       : DINT  := 0;    // Target turn count after gear ratio (exit condition)

    // ========================================== STATUS VARIABLES =======================================
    state                   : INT   := 0;    // Current state for state machine
    cnt                     : UINT  := 0;    // PLC cycle counter
    eta                     : LREAL := 0;    // Estimated time to completion in seconds
    etaFormattedString      : STRING(255);   // Formatted ETA string (M:S)
    progressPercent         : LREAL := 0;    // Progress percentage (0 to 100) based on turn count
    actualLinspeed          : LREAL := 0;    // Actual linear speed during operation

    // =============================================AXIS CONTROL========= ===================================
    payoff_axis_list        : ARRAY[1..GVL.MAX_PAYOFF_COUNT] OF FB_Axis;   // List of payoff axes
    pickup_axis_list        : ARRAY[1..GVL.MAX_PICKUP_COUNT] OF FB_Axis;   // List of pickup axes
    axis_list               : ARRAY[1..GVL.MAX_PAYOFF_COUNT+GVL.MAX_PICKUP_COUNT] OF POINTER TO FB_Axis; // Pointers to all axes (1: pickup, 2-4: payoff)

    // =============================================== MISCELLANEOUS =========================================
    tape_info               : ARRAY[0..10] OF tape_info; // Information about tape types
    numOfEnabledPayoff      : INT := 0;      // Number of enabled payoff reels
    tStart                  : TIME;          // Start time of operation
    tEnd                    : TIME;          // End time of operation
    tElapsed                : TIME;          // Elapsed time of operation
    allowInputEdits         : BOOL;          // Enable/disable input modifications
	estimatedTapeUsedM		: LREAL;		 //estimates tape used
	
    // =================================== COIL MODELS (currently not used) ===================================
    // Uncomment and use if needed in the future
    // coil_model_base_Xcords : ARRAY[0..MAX_COIL_TYPE_COUNT] OF ARRAY[1..MAX_SIZE_COIL_MODEL] OF LREAL;
    // coil_model_base_Ycords : ARRAY[0..MAX_COIL_TYPE_COUNT] OF ARRAY[1..MAX_SIZE_COIL_MODEL] OF LREAL;
    // coil_model_rot_Xcords  : ARRAY[0..MAX_COIL_TYPE_COUNT] OF ARRAY[1..MAX_SIZE_COIL_MODEL] OF LREAL;
    // coil_model_rot_Ycords  : ARRAY[0..MAX_COIL_TYPE_COUNT] OF ARRAY[1..MAX_SIZE_COIL_MODEL] OF LREAL;
END_VAR

VAR CONSTANT
    // =============================================== CONSTANT VALUES ===============================================
    input_bounds            : input_bounds;  // Defined bounds for input values
    MAX_COIL_TYPE_COUNT     : INT := 1;      // Number of coil types (counts from 0)
    MAX_SIZE_COIL_MODEL     : INT := 1205;   // Maximum size of coil model
    TARGET_PICKUP_FORCE     : LREAL := 10;   // Target force for pickup reel
    pi                      : LREAL := 4 * ATAN(1); // PI constant for calculations
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Methods" Id="{b393cdcb-7058-41c2-9d03-a8f8d00b2dde}">
      <Folder Name="Calculations" Id="{35fb52a4-9b2e-4543-81dd-47dc040f0a2d}" />
      <Folder Name="Checks" Id="{31e7abd2-ccee-45c1-9b72-50dc8913cecf}">
        <Folder Name="Error Checks" Id="{dad124df-88d7-4412-bdba-255c48b7272a}" />
        <Folder Name="Exit Checks" Id="{866f0ce9-c940-4c68-80f5-47885684bea2}" />
        <Folder Name="Input Checks" Id="{3dff40f9-587b-485b-8ffe-a3d1acaecd62}" />
      </Folder>
      <Folder Name="HMI updates" Id="{df5bfcf9-c740-45ae-b19d-3c3cd0aca00f}" />
      <Folder Name="Init Methods" Id="{313976c9-8371-4349-a1d4-ac334e51a051}" />
      <Folder Name="MISC" Id="{df8274f9-8bfd-43c2-9dbf-d95ad8873f48}" />
      <Folder Name="Motor Control" Id="{4367b06a-8be7-4cee-a828-1c414585ef9d}">
        <Folder Name="Axis Control" Id="{13190a97-e574-45c1-8d63-49afe41c0d88}">
          <Folder Name="Axis Control" Id="{49ec2768-53b2-482d-b44d-ec52fe555e63}" />
        </Folder>
        <Folder Name="misc" Id="{4727363e-bfa8-4742-943c-5f588420eeb1}" />
        <Folder Name="Misc Motor Control Routines" Id="{c85f6397-bdf7-4297-9e1c-8588c06febe6}" />
        <Folder Name="Standstill Methods" Id="{5a97690b-0fe1-4a36-b337-bb99efd53058}" />
        <Folder Name="Winding Methods" Id="{0f505234-4be9-4cf6-9596-76fb794045c8}" />
      </Folder>
      <Folder Name="Status Updates" Id="{912579cd-d079-4ec8-869a-781310624225}" />
    </Folder>
    <Method Name="accelerating_tension" Id="{51b0940c-2da9-428b-aa7c-7aa4bc946ef3}" FolderPath="Methods\Motor Control\Winding Methods\">
      <Declaration><![CDATA[METHOD accelerating_tension : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
	pickupLinspeed: LREAL;
	dist: LREAL;
	desiredVelocity: LREAL;
	adjustedVelocity: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[winding_tension();]]></ST>
      </Implementation>
    </Method>
    <Method Name="count_enabled_motors" Id="{4a842378-88e5-40ee-b5f2-32e4ab95fb86}" FolderPath="Methods\Motor Control\Axis Control\Axis Control\">
      <Declaration><![CDATA[METHOD count_enabled_motors : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[ //reads number of enabled payoff motors

numOfEnabledPayoff:=0;

FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
IF	payoff_axis_list[i].enabled THEN
	numOfEnabledPayoff:=numOfEnabledPayoff+1;
END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="CYCLIC" Id="{66242b1c-4d63-4218-b0e7-5f4fc34ce9db}">
      <Declaration><![CDATA[METHOD CYCLIC : BOOL
VAR
	
	i: INT;
	

	intital: BOOL;
	errorOutput: BOOL;
	errorStatus: BOOL;
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//cycle counter
cnt := cnt +1;

//-------------------------------------------------------------------------------------------------------------- USER INPUT --------------------------------------------------------------------------------------------------------------
CASE state OF
    10:
    // ========================================10========================================
    IF hmiConnection^.resetUI THEN
        reset();
        hmiConnection^.resetUI := FALSE;
    END_IF

    IF hmiConnection^.startUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to start winding while not in tension state',
                  strArg := '');
        hmiConnection^.startUI := FALSE;
    END_IF

    IF hmiConnection^.tensionUI THEN
        state := 20;
        errorOutput := TRUE;
    END_IF

    transfer_hmi_vars();

    IF hmiConnection^.homeUI THEN
        state := 50;
        errorOutput := TRUE;
    END_IF

    IF hmiConnection^.estopHW THEN
        state := 500;
    END_IF

    IF hmiConnection^.freespinUI THEN
        state := 11;
    END_IF

    // ========================================10========================================

    11:
    // ========================================11========================================
    IF NOT hmiConnection^.freespinUI THEN
        state := 10;
    END_IF

    IF hmiConnection^.resetUI THEN
        reset();
        hmiConnection^.resetUI := FALSE;
    END_IF

    IF hmiConnection^.startUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to start winding while not in tension state',
                  strArg := '');
        hmiConnection^.startUI := FALSE;
    END_IF

    IF hmiConnection^.tensionUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to start tension while in freespin state',
                  strArg := '');
        hmiConnection^.tensionUI := FALSE;
    END_IF

    IF hmiConnection^.homeUI THEN
        state := 50;
        errorOutput := TRUE;
    END_IF

    IF hmiConnection^.estopHW THEN
        state := 500;
    END_IF

    transfer_hmi_vars();
    // ========================================11========================================

    20, 21:
    // ========================================20========================================
    IF hmiConnection^.freespinUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to start freespin while not in standby state',
                  strArg := '');
        hmiConnection^.freespinUI := FALSE;
    END_IF

    IF hmiConnection^.resetUI THEN
        reset();
        hmiConnection^.resetUI := FALSE;
    END_IF

    IF hmiConnection^.startUI THEN
        state := 30;
        errorOutput := TRUE;
    END_IF

    IF NOT hmiConnection^.tensionUI THEN
        state := 10;
        errorOutput := TRUE;
    END_IF

    transfer_hmi_vars();

    IF hmiConnection^.homeUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to home outside of standby state',
                  strArg := '');
        hmiConnection^.homeUI := FALSE;
    END_IF

    IF hmiConnection^.estopHW THEN
        state := 500;
    END_IF
    // ========================================20========================================

    30, 31, 32, 33:
    // ========================================30========================================
    IF hmiConnection^.freespinUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to start freespin while not in standby state',
                  strArg := '');
        hmiConnection^.freespinUI := FALSE;
    END_IF

    IF hmiConnection^.resetUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to reset during winding. Please pause winding.',
                  strArg := '');
        hmiConnection^.resetUI := FALSE;
    END_IF

    IF NOT hmiConnection^.startUI THEN
        state := 20;
        errorOutput := TRUE;
    END_IF

    IF NOT hmiConnection^.tensionUI THEN
        hmiConnection^.startUI := FALSE;
        state := 10;
        errorOutput := TRUE;
    END_IF

   

    IF hmiConnection^.homeUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to home outside of standby state',
                  strArg := '');
        hmiConnection^.homeUI := FALSE;
    END_IF

    IF hmiConnection^.estopHW THEN
        state := 500;
    END_IF
    // ========================================30========================================

    40, 41:
    // ========================================40========================================
    IF hmiConnection^.freespinUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to start freespin while not in standby state',
                  strArg := '');
        hmiConnection^.freespinUI := FALSE;
    END_IF

    IF hmiConnection^.tensionUI THEN
        state := 40;
        errorOutput := TRUE;
    ELSE
        state := 41;
    END_IF

    IF hmiConnection^.resetUI THEN
        reset();
        hmiConnection^.resetUI := FALSE;
    END_IF

    IF hmiConnection^.startUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to start while finished. Please reset first.',
                  strArg := '');
        hmiConnection^.startUI := FALSE;
    END_IF

    IF hmiConnection^.homeUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to home outside of standby state',
                  strArg := '');
        hmiConnection^.homeUI := FALSE;
    END_IF

    IF hmiConnection^.estopHW THEN
        state := 500;
    END_IF
    // ========================================40========================================

    400:
    // ========================================400========================================
    IF hmiConnection^.freespinUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to start freespin while not in standby state',
                  strArg := '');
        hmiConnection^.freespinUI := FALSE;
    END_IF

    IF hmiConnection^.resetUI THEN
        reset();
        state := 10;
        hmiConnection^.resetUI := FALSE;
        errorOutput := TRUE;
    END_IF

    IF hmiConnection^.startUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to start while in error state. Please reset first, and resolve error.',
                  strArg := '');
        hmiConnection^.resetUI := FALSE;
    END_IF
	
    IF hmiConnection^.homeUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to home inside error state. Please resolve errors on enabled axises',
                  strArg := '');
        hmiConnection^.homeUI := FALSE;
    END_IF

    IF hmiConnection^.estopHW THEN
        state := 500;
    END_IF
    // ========================================400========================================

    50:
    // ========================================50========================================
    IF hmiConnection^.tensionUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to tension while in homing sdtate. Please stop homing.',
                  strArg := '');
        hmiConnection^.resetUI := FALSE;
    END_IF

    IF hmiConnection^.resetUI THEN
        reset();
        state := 10;
        hmiConnection^.resetUI := FALSE;
        errorOutput := TRUE;
    END_IF

    IF hmiConnection^.startUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to start while in homing sdtate. Please stop homing.',
                  strArg := '');
        hmiConnection^.resetUI := FALSE;
    END_IF

    transfer_hmi_vars();

    IF hmiConnection^.homeUI THEN
        hmiConnection^.homeUI := FALSE;
        state := 10;
        errorOutput := TRUE;
    END_IF

    IF hmiConnection^.estopHW THEN
        state := 500;
    END_IF
    // ========================================50========================================

    500:
    // ========================================500========================================
    IF hmiConnection^.tensionUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to tension while in ESTOP state. Please reset first.',
                  strArg := '');
        hmiConnection^.tensionUI := FALSE;
    END_IF

    IF hmiConnection^.resetUI THEN
        reset();
        state := 10;
        hmiConnection^.resetUI := FALSE;
        errorOutput := TRUE;
    END_IF

    IF hmiConnection^.startUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to start while in ESTOP state. Please reset first.',
                  strArg := '');
        hmiConnection^.startUI := FALSE;
    END_IF

    IF hmiConnection^.homeUI THEN
        ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
                  msgFmtStr := 'Error Occured. Unable to home while in ESTOP state. Please reset first.',
                  strArg := '');
        hmiConnection^.homeUI := FALSE;
    END_IF

    IF hmiConnection^.estopHW THEN
        state := 500;
    END_IF
    // ========================================500========================================
END_CASE
//-------------------------------------------------------------------------------------------------------------- USER INPUT --------------------------------------------------------------------------------------------------------------
	
//clear status vars for axis. we will update them depending on our current state.
pickup_axis_list[1].setClear();

FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	payoff_axis_list[i].setClear();
END_FOR

//check FOR error, IF error THEN set state TO 400

general_error_check(errorStatus=>errorStatus,errorOutput:=errorOutput);


//if no error, but currently in error state set winding to standby
//if none of the above state is unmodified
IF errorStatus THEN
	state:=400;
ELSIF state=400 AND NOT errorStatus THEN
	state:=10;
END_IF

//update HMI with certain motor values. 
hmi_update();
find_actualLinspeed();
update_TC();
update_axis_distance();


//-------------------------------------------------------------------------------------------------------------- MOTOR CONTROL --------------------------------------------------------------------------------------------------------------
CASE state OF
	00: //INIT STATE
	
	tstart:=TIME();
	state:=10;
	// ========================================10========================================
	10: //STANDBY STATE. 
	//wait for user inputs to transition to tension state. All motors are idle. Can edit params
	
	stop_all();
	allowInputEdits:=TRUE;
	// ========================================10========================================
	
	// ========================================11========================================
	11:
	allowInputEdits:=TRUE;
	freespin_all();
	// ========================================11========================================
	// ========================================20========================================
	20: //STANDBY WITH STANDSTILL TENSION INITAL
	//inital error check for standstill tension state
	allowInputEdits:=FALSE;
	count_enabled_motors();
	//check inputs for standstill tension
	IF standstill_tension_check() THEN
		//if error then revert to standby
		state:=10;
		hmiConnection^.tensionUI:=FALSE;
	ELSE
		state:=21;
		
	END_IF
	// ========================================20========================================
	
	// ========================================21========================================
	21://STANDBY WITH STANDSTILL TENSION
	//no movement in cable, but tension is being created. waiting on user inputs to start winding. Can edit params
	
	
	standstill_tension();
	// ========================================21========================================

	// ========================================30========================================
	30: //WINDING TENSION INITAL
	//inital error check for winding tension state.
	allowInputEdits:=FALSE;
	count_enabled_motors();
	// INPUT VALIDATION
	IF winding_check() THEN
		//if error then revert to standby
		state:=20;
		hmiConnection^.startUI:=FALSE;
		
		
		
	ELSE
		eventLogger^.fbMessage[1].Send(0);
		state:=31;
		tStart:=TIME();
	END_IF
	// ========================================30========================================
	
	// ========================================31========================================
	31: //WINDING TENSION, ACCELERATION
	//coil is currently ramping speed. can not edit params.
	
	

	
	accelerating_tension();
	determine_motor_state();
	tElapsed:=TIME() -tStart;
	
	IF winding_exit_check() THEN
	
		state:=39;
		
	ELSE
		state:=31;
	END_IF
	
	
	// ========================================31========================================
	
	// ========================================32========================================
	32: //WINDING TENSION, STEADY STATE
	//coil is in steady state. moving at constant velo with set tension. Can not edit params
	
	
	
	winding_tension();
	determine_motor_state();
	tElapsed:=TIME() -tStart;

	//check for exit conditions 
	IF winding_exit_check() THEN
		
		state:=39;
		
	ELSE
		state:=32;
	END_IF
	
	
	
	// ========================================32========================================
	
	// ========================================33========================================
	33: //WINDING TENSION, DEACCELERATION
	//coil currently decreasing speed, while maintaining. Can not edit params
	

	
	decelerating_tension();
	determine_motor_state();
	tElapsed:=TIME() -tStart;

	//check for exit conditions 
	IF winding_exit_check() THEN
		
		state:=39;
		
	ELSE
		state:=33;
	END_IF
	// ========================================33========================================
	
	// ========================================39========================================
	39: // transition state from winding => finished
		eventLogger^.fbMessage[2].Send(0);
		hmiConnection^.startUI:=FALSE;
		
		tEnd:=TIME();
		tElapsed:=tEnd -Tstart;
		
		fileReadWrite^.update_database(user:= 'TO DO figure out how to get user information',
										timeStarted:=tStart,
										timeCompleted:=tEnd,
										timeElasped:=tElapsed,
										numOfCoil:=numOfEnabledPayoff,
										lengthOCoil:=find_tape_length_used(),
										userNote:=hmiConnection^.userNote);
		fileReadWrite^.bInitWrite:=TRUE;			
		
	
		state:=40;
	// ========================================39========================================
	
	
	// ========================================40========================================
	40: //FINISHED HOLD STANDSTILL TENSION
	//cable winding finished, currently mainting tension until user input. Can not edit params
	allowInputEdits:=FALSE;
	standstill_tension();
	
	IF standstill_tension_check() THEN
		//if error then revert to standby
		state:=51;
		
	ELSE
		state:=40;
		
	END_IF
	// ========================================40========================================
	
	// ========================================41========================================
	41: //FINISHED NO TENSION
	//cable winding finished, waiting on user reset to transition to standby state. Can edit params
	//do not control tension
	stop_all();
	// ========================================41========================================
	

	// ========================================50========================================
	50:
	//exit homing state if homing is done or error.
	allowInputEdits:=FALSE;
	IF set_pos_all() THEN
		state:=10;
		hmiConnection^.homeUI:=FALSE;
	
	ELSE
		state:=50;
	END_IF
	
	
	
	
	
	// ========================================50========================================
	
	// ========================================60========================================
	60:
	//exit homing state if homing is done or error.
		allowInputEdits:=FALSE;
	IF Home() THEN
		state:=10;
		hmiConnection^.homeUI:=FALSE;
	
	ELSE
		state:=50;
	END_IF
	
	
	// ========================================60========================================
	
	
	400: //ERROR STATE
	//error on a axis preventing motor movement, or winding start. //do nothing 'till resolved
		allowInputEdits:=FALSE;
	500: //ESTOP STATE
	//triggered on estop press. can be cleared with reset
	
		hmiConnection^.tensionUI:=FALSE;
		hmiConnection^.freespinUI:=FALSE;
		hmiConnection^.startUI:=FALSE;
		allowInputEdits:=FALSE;
		estop_routine();
		
	
END_CASE
//-------------------------------------------------------------------------------------------------------------- MOTOR CONTROL --------------------------------------------------------------------------------------------------------------

//get status updates
//only calculate once very N turns in order to save resources. there also shouldnt be need to run eveyr plc cycle
	
IF (cnt MOD 10 =0) and  NOT(desiredLinspeed = 0) THEN
	etaFormattedString:=find_eta();
	progressPercent :=get_current_progress();
END_IF


//Call cyclic methods of all axies 
pickup_axis_list[1].CYLIC();

FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	payoff_axis_list[i].CYLIC();
END_FOR


]]></ST>
      </Implementation>
    </Method>
    <Method Name="decelerating_tension" Id="{c76da513-9eeb-4494-921e-e9d30e1467af}" FolderPath="Methods\Motor Control\Winding Methods\">
      <Declaration><![CDATA[METHOD decelerating_tension : BOOL
VAR_INPUT
END_VAR
 ]]></Declaration>
      <Implementation>
        <ST><![CDATA[winding_tension();]]></ST>
      </Implementation>
    </Method>
    <Method Name="determine_motor_state" Id="{e8b4b006-30e0-4934-923d-a97aac10b32d}" FolderPath="Methods\Motor Control\misc\">
      <Declaration><![CDATA[METHOD determine_motor_state : BOOL
VAR_INPUT
END_VAR





VAR
	actualLinspeed : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//to do . comeback on this and do a once over. not sure if this is what we want.
			
actualLinspeed:=pickup_axis_list[1].getDistToAxis()*pickup_axis_list[1].actualVelocity/57.29578;
		
//if we are below our desired
IF actualLinspeed <= 0.9*desiredLinspeed THEN
	
	state:=31;

//last turn dedicated to decelerating 
ELSIF pickup_axis_list[1].AXIS.NcToPlc.ModuloActTurns = desiredTurnCountPickup-1 THEN

	state:=33;

//if not accelerating or decelerating then we are in steady state
ELSE

	state:=32;
	
END_IF

 
	
	


]]></ST>
      </Implementation>
    </Method>
    <Method Name="estop_routine" Id="{e370fdf5-060a-481a-8925-f8c00351b401}" FolderPath="Methods\Motor Control\Misc Motor Control Routines\">
      <Declaration><![CDATA[METHOD estop_routine : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//during estop, cut power to motors.

//turn power off on all axies. 
pickup_axis_list[1].MCPOWER(Axis:=pickup_axis_list[1].AXIS,ENABLE:=FALSE);

FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
		payoff_axis_list[i].MCPOWER(Axis:=payoff_axis_list[i].AXIS,ENABLE:=FALSE);
END_FOR
	
			
	











]]></ST>
      </Implementation>
    </Method>
    <Method Name="find_actualLinspeed" Id="{823ec0fb-b191-48ce-920c-8a8209069cf1}" FolderPath="Methods\Calculations\">
      <Declaration><![CDATA[METHOD find_actualLinspeed : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[actualLinspeed:=pickup_axis_list[1].actualVelocity*pickup_axis_list[1].outerRadiusCurrent;]]></ST>
      </Implementation>
    </Method>
    <Method Name="find_eta" Id="{85e42879-e4fd-44ad-b45f-475c7a661596}" FolderPath="Methods\Calculations\">
      <Declaration><![CDATA[//updates eta var
METHOD find_eta : STRING(255)
VAR
	length : LREAL; //length of straight sections in race track coil
	minutes: DINT;
	
	seconds: DINT;
	minutesString: STRING;
	secondsString: STRING;
	formattedString: STRING(255);
	tape_thicnes: LREAL :=0; //total tape thickness in meters
	i: INT;
	total_circum: LREAL;
	currentTurnCount: LREAL;
	currentCircum: LREAL;
END_VAR
VAR CONSTANT
	pi : LREAL := 4 * ATAN(1);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//if we are finished out put 0 seconds and exit
IF state <=59 AND state >= 50 THEN
eta:=0;
RETURN ;
END_IF

CASE pickup_axis_list[1].coilShapeID OF
	//finds eta given turn count
	//formulas are a function of circumfrence given turn count. we take the intergral of this, with respect to turn count, with the upper bound being our target turn count 
	0:
	
	tape_thicnes:=0;
	FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
		IF payoff_axis_list[i].enabled THEN
		tape_thicnes:=tape_thicnes+payoff_axis_list[i].tape_info^[payoff_axis_list[i].tapeType].tape_depth/1000;
		END_IF
	END_FOR
	

	
	
	
	
	//finds current turn count. 
	currentTurnCount:=(pickup_axis_list[1].AXIS.NcToPlc.ModuloActPos/360+pickup_axis_list[1].AXIS.NcToPlc.ModuloActTurns);
	

	IF NOT(pickup_axis_list[1].AXIS.NcToPlc.ActVelo =0) THEN
		eta:=(desiredTurnCountPickup*360-currentTurnCount*360)/(pickup_axis_list[1].AXIS.NcToPlc.ActVelo);
	ELSE
		eta:=0;
	END_IF
	

	
	
	
	1:	
	// to do. update this monster of a formula for the race track coil. derived through calculus, which is probably correct, just now cant figure it out because i decided to write a one liner instead of splitting up
	(*
	eta:=((2*pi*racetrack_params.radius*target_turn_count_pickup+pi*tape_info.tape_depth*target_turn_count_pickup*target_turn_count_pickup+2*racetrack_params.length*target_turn_count_pickup)
		 -(2*pi*racetrack_params.radius*pickup_motor_list[1].turn_count+pi*tape_info.tape_depth*target_turn_count_pickup*pickup_motor_list[1].turn_count+2*racetrack_params.length*pickup_motor_list[1].turn_count));
		 *)
END_CASE


IF eta < 0 OR eta > 1E6 THEN
	eta:=0;
END_IF

// Convert the LREAL value to minutes and seconds
minutes := TRUNC(eta / 60);
seconds := TRUNC(eta - (minutes * 60));


// Convert the minutes and seconds to strings
minutesString := DINT_TO_STRING(minutes);

IF seconds < 10 THEN
	secondsString :=CONCAT('0', DINT_TO_STRING(seconds)) ;
ELSE
	secondsString := DINT_TO_STRING(seconds);
END_IF


// Format the final output string
find_eta := CONCAT(CONCAT('ETA: ', minutesString), CONCAT(':', secondsString));
]]></ST>
      </Implementation>
    </Method>
    <Method Name="find_tape_length_used" Id="{7ea290bf-df4e-4690-9fae-b92992bd262d}" FolderPath="Methods\Calculations\">
      <Declaration><![CDATA[METHOD find_tape_length_used : LREAL
VAR_INPUT
END_VAR

VAR
	tape_thicnes: LREAL;
	i: INT;
	total_circum: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[

CASE pickup_axis_list[1].coilShapeID OF
	//finds eta given turn count
	//formulas are a function of circumfrence given turn count. we take the intergral of this, with respect to turn count, with the upper bound being our target turn count 
	0:
	
	tape_thicnes:=0;
	FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
		IF payoff_axis_list[i].enabled THEN
		tape_thicnes:=tape_thicnes+payoff_axis_list[i].tape_info^[payoff_axis_list[i].tapeType].tape_depth/1000;
		END_IF
	END_FOR
	
	total_circum:=2*pi*desiredTurnCountPickup*pickup_axis_list[1].pancake.radius/1000 + tape_thicnes*EXPT(desiredTurnCountPickup,2)*pi;
	
	1:	
	// to do. update this monster of a formula for the race track coil. derived through calculus, which is probably correct, just now cant figure it out because i decided to write a one liner instead of splitting up
	(*
	eta:=((2*pi*racetrack_params.radius*target_turn_count_pickup+pi*tape_info.tape_depth*target_turn_count_pickup*target_turn_count_pickup+2*racetrack_params.length*target_turn_count_pickup)
		 -(2*pi*racetrack_params.radius*pickup_motor_list[1].turn_count+pi*tape_info.tape_depth*target_turn_count_pickup*pickup_motor_list[1].turn_count+2*racetrack_params.length*pickup_motor_list[1].turn_count));
		 *)
END_CASE



find_tape_length_used:=total_circum;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="freespin_all" Id="{297992c1-22a1-4bab-9fd1-a180ef589cdf}" FolderPath="Methods\Motor Control\misc\">
      <Declaration><![CDATA[METHOD freespin_all : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//disables all movement functions on all axis

pickup_axis_list[1].setFree();
		
FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
		
	payoff_axis_list[i].setFree();
			
		
END_FOR 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="general_error_check" Id="{8ba42383-7e8f-4747-9137-d6b0ee74634e}" FolderPath="Methods\Checks\Error Checks\">
      <Declaration><![CDATA[METHOD general_error_check : BOOL
VAR
	i: INT;
	pickup_motor_count: INT;
	adsError : BOOL;
END_VAR
VAR_OUTPUT
	errorStatus : BOOL ;
END_VAR
VAR_IN_OUT
	errorOutput: BOOL ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Checks to see if there are any errors in a enabled axis.


pickup_axis_list[1].error_check_all();

errorStatus:=pickup_axis_list[1].AXIS.Status.Error OR pickup_axis_list[1].adsError ;
		
IF errorOutput AND pickup_axis_list[1].AXIS.Status.Error THEN
			
			ADSLOGSTR(
        		msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        		msgFmtStr := 'Error occurred. Error on Pickup Axis with ID: %S',
        		strArg := UDINT_TO_STRING(pickup_axis_list[1].AXIS.Status.ErrorID)
   			 );
		
			errorOutput:=FALSE;
		
END_IF
		
IF errorOutput AND pickup_axis_list[1].adsError THEN
			
			ADSLOGSTR(
        		msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        		msgFmtStr := 'Error occurred. Error in Pickup Axis FB with ID: %S ',
        		strArg := UDINT_TO_STRING(pickup_axis_list[1].adsErrorID)
   			 );
		
			errorOutput:=FALSE;
		
END_IF



FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	
	payoff_axis_list[i].error_check_all();

	
		errorStatus:=errorStatus OR ((payoff_axis_list[i].AXIS.Status.Error OR payoff_axis_list[i].adsError) AND payoff_axis_list[i].enabled);
		
		IF errorOutput AND payoff_axis_list[i].AXIS.Status.Error THEN
			
			ADSLOGSTR(
        		msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        		msgFmtStr := 'Error occurred. Error on Pickup Axis with ID: %S',
        		strArg := UDINT_TO_STRING(payoff_axis_list[i].AXIS.Status.ErrorID)
   			 );
		
			errorOutput:=FALSE;
		
END_IF
		
IF errorOutput AND payoff_axis_list[i].adsError THEN
			
			ADSLOGSTR(
        		msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        		msgFmtStr := 'Error occurred. Error in Pickup Axis FB with ID: %S ',
        		strArg := UDINT_TO_STRING(payoff_axis_list[i].adsErrorID)
   			 );
		
			errorOutput:=FALSE;
		
END_IF
		
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="general_input_check" Id="{a3d14995-b6bb-4412-80c9-b4d7fa9675b0}" FolderPath="Methods\Checks\Input Checks\">
      <Declaration><![CDATA[METHOD general_input_check : BOOL
VAR_INPUT
	write: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//does general input checks before 

IF hmiConnection^.general_input_datagrid_params_list[1].tension < input_bounds.tension_low OR hmiConnection^.general_input_datagrid_params_list[1].tension > input_bounds.tension_high THEN
	general_input_check := TRUE;
	
	ADSLOGSTR(
        	msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        	msgFmtStr := 'Error occurred. Tension outside of range. ',
        	strArg := ''
   		 );
	
ELSE
	
	IF write THEN
		desiredTension:=hmiConnection^.general_input_datagrid_params_list[1].tension;
	
	END_IF
END_IF

IF hmiConnection^.general_input_datagrid_params_list[1].linspeed < input_bounds.linear_speed_low OR hmiConnection^.general_input_datagrid_params_list[1].linspeed > input_bounds.linear_speed_high THEN
	general_input_check := TRUE;
	
	ADSLOGSTR(
        	msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        	msgFmtStr := 'Error occurred. Linear speedc out of range.',
        	strArg := ''
   		 );
	
ELSE
	IF write THEN
		desiredLinspeed:=hmiConnection^.general_input_datagrid_params_list[1].linspeed;
	
	END_IF
	
END_IF

IF write THEN
	unwinding:=hmiConnection^.general_input_datagrid_params_list[1].unwinding;
	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="get_current_progress" Id="{504eb237-53a6-4e39-b7e7-217f0cf72225}" FolderPath="Methods\Status Updates\">
      <Declaration><![CDATA[METHOD get_current_progress : LREAL

VAR
	prog : LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF unwinding THEN
	prog := 100-(pickup_axis_list[1].AXIS.NcToPlc.ModuloActTurns/desiredTurnCountPickup)*100;
	
ELSE
	prog := ((pickup_axis_list[1].AXIS.NcToPlc.ModuloActPos/360+pickup_axis_list[1].AXIS.NcToPlc.ModuloActTurns)/desiredTurnCountPickup)*100;

END_IF
	


IF (0 < prog AND prog < 100) THEN
	
	get_current_progress:=prog;
	
ELSIF prog > 100 THEN
	
	prog:=100;

ELSIF prog < 0 THEN
	
	prog:=0;
	
END_IF
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="get_dist_to_axis_pickup" Id="{5e8d7d35-891f-492e-a6ba-1fda137d3e90}" FolderPath="Methods\Status Updates\">
      <Declaration><![CDATA[METHOD get_dist_to_axis_pickup : LREAL
VAR
	dist : LREAL;
	i: INT;
	temp: LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Finds distance to axis from internal dimension and turn count vars. 

//NOTE: this only works for payoff axies. 

//output units in mm. IMPORTANT

CASE pickup_axis_list[1].coilShapeID OF
	0:
	
	CASE pickup_axis_list[1].directionB OF
		
	0: //Finds direction if motor is being wound
	
	dist:=(pickup_axis_list[1].pancake.radius)/1000; 
	
	FOR i:=1 TO numOfEnabledPayoff DO
		IF payoff_axis_list[i].enabled THEN
			temp:=temp +(pickup_axis_list[1].axis.NcToPlc.ModuloActTurns*payoff_axis_list[i].tape_info^[payoff_axis_list[i].tapeType].tape_depth)/(1000);
		END_IF
		dist:=dist+temp;
		
	END_FOR
	1: //Finds direction if motor is being unwound

	
	dist:=(pickup_axis_list[1].pancake.radius)/1000; 
	
		FOR i:=1 TO numOfEnabledPayoff DO
		IF payoff_axis_list[i].enabled THEN
			temp:=temp +(pickup_axis_list[1].axis.NcToPlc.ModuloActTurns*payoff_axis_list[i].tape_info^[payoff_axis_list[i].tapeType].tape_depth)/(1000);
		END_IF
		dist:=dist-temp;
		
	END_FOR
	
	END_CASE
	
	
	
	
	
	1://TO DO. IMPLEMENT OTHER COIL IDS BESDIES PANCAKE
END_CASE
get_dist_to_axis_pickup:=dist;]]></ST>
      </Implementation>
    </Method>
    <Method Name="hmi_update" Id="{15a1114f-a0f7-4eca-8f18-4cf797395fba}" FolderPath="Methods\HMI updates\">
      <Declaration><![CDATA[METHOD hmi_update : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//collection of functions to update hmi vars. 

hmiConnection^.state:=state;

hmiConnection^.overview_outputs_datagrid_list[1].pickupTurnCount:=(pickup_axis_list[1].AXIS.NcToPlc.ModuloActPos/360+pickup_axis_list[1].AXIS.NcToPlc.ModuloActTurns);
hmiConnection^.overview_outputs_datagrid_list[1].linspeed:=pickup_axis_list[1].actualVelocity*pickup_axis_list[1].outerRadiusCurrent/57.29578;

hmiConnection^.overview_outputs_datagrid_list[1].torque:=pickup_axis_list[1].actualTorque/pickup_axis_list[1].outerRadiusCurrent;

hmiConnection^.turncount_output_datagrid_list[1].pickupTC1:=(pickup_axis_list[1].AXIS.NcToPlc.ModuloActPos/360+pickup_axis_list[1].AXIS.NcToPlc.ModuloActTurns);
hmiConnection^.turncount_output_datagrid_list[1].payoffTC1:=(payoff_axis_list[1].AXIS.NcToPlc.ModuloActPos/360+payoff_axis_list[1].AXIS.NcToPlc.ModuloActTurns);
hmiConnection^.turncount_output_datagrid_list[1].payoffTC2:=(payoff_axis_list[2].AXIS.NcToPlc.ModuloActPos/360+payoff_axis_list[2].AXIS.NcToPlc.ModuloActTurns);
hmiConnection^.turncount_output_datagrid_list[1].payoffTC3:=(payoff_axis_list[3].AXIS.NcToPlc.ModuloActPos/360+payoff_axis_list[3].AXIS.NcToPlc.ModuloActTurns);


FOR i:=1 TO gvl.MAX_PAYOFF_COUNT+gvl.MAX_PICKUP_COUNT DO
	hmiConnection^.motor_info_datagrid_list[i].errorType:=axis_list[i]^.errorType;
	hmiConnection^.motor_info_datagrid_list[i].errorID:=axis_list[i]^.errorID;
	hmiConnection^.motor_info_datagrid_list[i].currentRadius:=axis_list[i]^.outerRadiusCurrent;
END_FOR

//calls other hmi update methods
update_error_status();
update_torque();
update_velocity();]]></ST>
      </Implementation>
    </Method>
    <Method Name="home" Id="{e2c62351-b82f-409f-8c6d-bb5032e701a1}" FolderPath="Methods\Motor Control\Misc Motor Control Routines\">
      <Declaration><![CDATA[METHOD home : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
	busytemp: BOOL;
	errortemp: BOOL;
	busy: INT;
	error: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//inital jog (so function not closed right away) 











]]></ST>
      </Implementation>
    </Method>
    <Method Name="INIT" Id="{a56443b6-9d3c-4e19-bf68-551e95d54fd0}">
      <Declaration><![CDATA[METHOD INIT : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[init_coil_model();
//Call cyclic methods of all axies 

pickup_axis_list[1].INIT();

pickup_axis_list[1].torqueConstant:=GVL.PICKUP_TORQUE_CONSTANT;
pickup_axis_list[1].ratedCurrent:=GVL.PICKUP_RATED_CURRENT;
pickup_axis_list[1].enabled:=TRUE;

pickup_axis_list[1].gearRatioNum:=10;
pickup_axis_list[1].gearRatioDen:=1;
pickup_axis_list[1].tape_info:=ADR(tape_info);

FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	payoff_axis_list[i].INIT();
	payoff_axis_list[i].torqueConstant:=GVL.PAYOFF_TORQUE_CONSTANT;
	payoff_axis_list[i].ratedCurrent:=GVL.PAYOFF_RATED_CURRENT;
	payoff_axis_list[i].gearRatioNum:=60;
	payoff_axis_list[i].gearRatioDen:=1;
	payoff_axis_list[i].tape_info:=ADR(tape_info);
	
END_FOR

etaFormattedString := CONCAT(CONCAT('ETA: ', '0'), CONCAT(':', '0'));


axis_list[1]:=ADR(pickup_axis_list[1]);
axis_list[2]:=ADR(payoff_axis_list[1]);
axis_list[3]:=ADR(payoff_axis_list[2]);
axis_list[4]:=ADR(payoff_axis_list[3]);]]></ST>
      </Implementation>
    </Method>
    <Method Name="init_coil_model" Id="{90edf354-a001-4a69-9922-1b60f25b1548}" FolderPath="Methods\Init Methods\">
      <Declaration><![CDATA[METHOD init_coil_model : BOOL
VAR 
	med_val : LREAL; // intermediate value 
	i :INT ;
	
	coil_type: INT:=0;
	cnt: INT :=0; //temp
END_VAR
VAR CONSTANT
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//TO DO this funciton was orginall made to create a model of a non circular pickup coil shape. i would like to redo it. 

(*



	//1:
	//creates 1205 points to model a race track coil. we do this 
	cnt:=0;
	FOR i := -150 TO 150 DO
    	coil_model_base_Xcords[1][i+151]:=racetrack_params_1.radius+pickup_motor_list[1].turn_count*tape_info.tape_depth;
		coil_model_base_Ycords[1][i+151]:=i;
		
		
	END_FOR;
	FOR i := -150 TO 150 DO
    	coil_model_base_Xcords[1][i+452]:=-(coil_shape_params.radius+pickup_motor_list[1].turn_count*tape_info.tape_depth);
		coil_model_base_Ycords[1][i+452]:=i;
	
	END_FOR;
	FOR i := -150 TO 150 DO
		med_val:=(pi/300)*i+pi;
		
		
    	coil_model_base_Xcords[1][i+753]:=(coil_shape_params.radius+pickup_motor_list[1].turn_count*tape_info.tape_depth)*SIN(med_val);
		coil_model_base_Ycords[1][i+753]:=-1*coil_shape_params.length*COS(med_val);
	
	END_FOR;
	FOR i := -150 TO 150 DO
		med_val:=(pi/300)*i;
		
		
    	coil_model_base_Xcords[1][i+904]:=(coil_shape_params.radius+pickup_motor_list[1].turn_count*tape_info.tape_depth)*SIN(med_val);
		coil_model_base_Ycords[1][i+904]:=coil_shape_params.length*COS(med_val);
	
	END_FOR;
	 
*)]]></ST>
      </Implementation>
    </Method>
    <Method Name="payoff_input_check" Id="{70c3f949-5037-419d-bccb-87705ebd3434}" FolderPath="Methods\Checks\Input Checks\">
      <Declaration><![CDATA[METHOD payoff_input_check : BOOL
VAR_INPUT
END_VAR

VAR_input
	write: BOOL;
END_VAR
VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//write inputs from payoff data grids to payof axis 

FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	
	IF write THEN
		payoff_axis_list[i].enabled:=hmiConnection^.payoff_input_datagrid_params_list[i].enabled;
		payoff_axis_list[i].tapeType:=hmiConnection^.payoff_input_datagrid_params_list[i].tape_type;
		payoff_axis_list[i].pancake.radius:=hmiConnection^.payoff_input_datagrid_params_list[i].radius;
	END_IF

	
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="read_status" Id="{c26500a1-9771-4061-a160-1627c7f00ff3}" FolderPath="Methods\Motor Control\Axis Control\Axis Control\">
      <Declaration><![CDATA[METHOD read_status : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[ //updates status of all axises, pickup and payoff

pickup_axis_list[1].Axis.ReadStatus();


FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	payoff_axis_list[i].AXIS.ReadStatus();
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="reset" Id="{aef7dc8a-f8b9-41a2-9568-128920b7af80}" FolderPath="Methods\MISC\">
      <Declaration><![CDATA[METHOD reset : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//resets program to inital state, clears any error. 

state := 10;
progressPercent:=0;

fileReadWrite^.reset();

// reset axis's, clear errors
pickup_axis_list[1].reset();
		
pickup_axis_list[1].SoEReset(axis:=pickup_axis_list[1].AXIS,Execute:=FALSE);

pickup_axis_list[1].SoEReset(axis:=pickup_axis_list[1].AXIS,Execute:=TRUE);

FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
		
			payoff_axis_list[i].reset();
			
		
END_FOR 

]]></ST>
      </Implementation>
    </Method>
    <Method Name="set_pos_all" Id="{dae62719-33d8-49b6-8821-ff4d77998180}" FolderPath="Methods\Motor Control\misc\">
      <Declaration><![CDATA[METHOD set_pos_all : BOOL
VAR_INPUT
END_VAR

VAR

	i: INT;
	busy : BOOL :=FALSE;
	busytemp : BOOL := FALSE;
	error : BOOL:= FALSE;
	errorTemp : BOOL := FALSE;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//function to set pos of all motors to 0

//turn power off on all axies. need for set pos function
pickup_axis_list[1].MCPOWER(Axis:=pickup_axis_list[1].AXIS,ENABLE:=FALSE);

FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
	IF payoff_axis_list[i].enabled THEN
			
		payoff_axis_list[i].MCPOWER(Axis:=payoff_axis_list[i].AXIS,ENABLE:=FALSE);
	END_IF
END_FOR 




//set pos, repeat till not busy or error
REPEAT
	
	//set pos of pickup
	pickup_axis_list[1].MCPOS(Axis:=pickup_axis_list[1].Axis,Execute:=TRUE,Position:=0,MODE:=FALSE,busy=>busytemp,Error=>errortemp);
	busy:= busy AND busytemp;
	error:= error AND errorTemp;


//set pos of payoff
	FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
		IF payoff_axis_list[i].enabled THEN
			
			payoff_axis_list[i].MCPOS(Axis:=payoff_axis_list[i].Axis,Execute:=TRUE,Position:=0,MODE:=FALSE,busy=>busytemp,Error=>errortemp);
			busy:=busy AND busytemp;
			error:= error AND errorTemp;
		END_IF
	END_FOR 


//exit condition	
UNTIL 
//exit when all axies are no longer busy
NOT BUSY
END_REPEAT

pickup_axis_list[1].MCPOS(Axis:=pickup_axis_list[1].Axis, Execute:=TRUE,Position:=0,mode:=FALSE);

//turn power off on all axies. 
pickup_axis_list[1].MCPOWER(Axis:=pickup_axis_list[1].AXIS,ENABLE:=TRUE);
pickup_axis_list[1].MCPOS(Axis:=pickup_axis_list[1].Axis,Execute:=FALSE,Position:=0,MODE:=FALSE,busy=>busytemp,Error=>errortemp);

FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
	IF payoff_axis_list[i].enabled THEN
		payoff_axis_list[i].MCPOWER(Axis:=payoff_axis_list[i].AXIS,ENABLE:=TRUE);
		payoff_axis_list[i].MCPOS(Axis:=payoff_axis_list[i].Axis,Execute:=FALSE,Position:=0,MODE:=FALSE,busy=>busytemp,Error=>errortemp);
			busy:=busy AND busytemp;
	END_IF		
END_FOR 

set_pos_all:=NOT ERROR;







]]></ST>
      </Implementation>
    </Method>
    <Method Name="standstill_tension" Id="{2810c0a6-5d8e-4e25-8bef-5c7267116cff}" FolderPath="Methods\Motor Control\Standstill Methods\">
      <Declaration><![CDATA[METHOD standstill_tension : BOOL
VAR_INPUT
	
END_VAR

VAR
	
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//creates tension in tape, but does not move the tape.

//set torque to force times number of payoff motors enabled. 

pickup_axis_list[1].torque:=((desiredTension*numOfEnabledPayoff* pickup_axis_list[1].outerRadiusCurrent)/2)+GVL.MIN_THRESHOLD_TORQUE;
	
//TO DO need to find what to set these to. might be too low. 
pickup_axis_list[1].velocityLimitLow:=0;
pickup_axis_list[1].velocityLimitHigh:=100;
	
	
pickup_axis_list[1].setTorque();
	
	
FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
	IF payoff_axis_list[i].enabled THEN
		payoff_axis_list[i].setTorque();
		
		payoff_axis_list[i].velocityLimitLow:=-100;
		payoff_axis_list[i].velocityLimitHigh:=-0;
		payoff_axis_list[i].torque:=-1*((desiredTension*	payoff_axis_list[i].outerRadiusCurrent/2)+GVL.MIN_THRESHOLD_TORQUE);
			
	END_IF
END_FOR 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="standstill_tension_check" Id="{4514199c-9af5-4a98-ad75-0298298ebf12}" FolderPath="Methods\Checks\Input Checks\">
      <Declaration><![CDATA[METHOD standstill_tension_check : BOOL
VAR_OUTPUT

END_VAR
VAR
	input_bounds : input_bounds; //struct defining input bounds
	i: INT; //counter
	
	
	payoffEnableCheck :BOOL :=FALSE; //var to hold payoff enable var
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//check to see if HMI vars are valid for stand still tension before winding. outputs true if there was an error.

//PICKUP AXIS CHECKS
payoff_input_check(write:=TRUE);

IF hmiConnection^.general_input_datagrid_params_list[1].tension < input_bounds.tension_low OR hmiConnection^.general_input_datagrid_params_list[1].tension > input_bounds.tension_high THEN
	standstill_tension_check := TRUE;
	
	ADSLOGSTR(
        	msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        	msgFmtStr := 'Error occurred. Tension outside of range. Unable to start tension',
        	strArg := ''
   		 );
	
ELSE
	desiredTension:=hmiConnection^.general_input_datagrid_params_list[1].tension;
	
END_IF

//PAYOFF AXIS CHECKS

FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	payoffEnableCheck:=payoffEnableCheck OR hmiConnection^.payoff_input_datagrid_params_list[i].enabled;
	

	
END_FOR


IF NOT payoffEnableCheck THEN
	standstill_tension_check := TRUE;
	
	ADSLOGSTR(
        	msgCtrlMask := ADSLOG_MSGTYPE_ERROR OR ADSLOG_MSGTYPE_MSGBOX,
        	msgFmtStr := 'Error occurred. At least one payoff motor needs to be enabled',
        	strArg := ''
   		 );

END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="stop_all" Id="{91a32785-37fe-490f-8e36-a7fa897334e3}" FolderPath="Methods\Motor Control\misc\">
      <Declaration><![CDATA[METHOD stop_all : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//sets stop parameter for all motors

pickup_axis_list[1].setStop();
		
FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
		
	payoff_axis_list[i].setStop();
			
END_FOR 

]]></ST>
      </Implementation>
    </Method>
    <Method Name="transfer_hmi_vars" Id="{a22def73-99d5-4798-8700-74bd55b9eec0}" FolderPath="Methods\MISC\">
      <Declaration><![CDATA[METHOD transfer_hmi_vars : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//transfer vars from hmi to windingcontrol

//general
desiredTension:=hmiConnection^.general_input_datagrid_params_list[1].tension;

desiredLinspeed:=hmiConnection^.general_input_datagrid_params_list[1].linspeed;

unwinding:=hmiConnection^.general_input_datagrid_params_list[1].unwinding;

//pickup

desiredTurnCountPickup:=hmiConnection^.pickup_input_datagrid_params_list[1].turn_count;
pickup_axis_list[1].coilShapeID:=hmiConnection^.pickup_input_datagrid_params_list[1].coil_shape;
pickup_axis_list[1].pancake.radius:=hmiConnection^.pickup_pancake_input_datagrid_params_list[1].radius;
//payoff
 FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	

	payoff_axis_list[i].enabled:=hmiConnection^.payoff_input_datagrid_params_list[i].enabled;
	payoff_axis_list[i].tapeType:=hmiConnection^.payoff_input_datagrid_params_list[i].tape_type;
	
	payoff_axis_list[i].pancake.radius:=hmiConnection^.payoff_input_datagrid_params_list[i].radius;
		
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="turncount_check" Id="{4c7cb2bc-d2fc-4d92-bc21-97258f109b7a}" FolderPath="Methods\Checks\Input Checks\">
      <Declaration><![CDATA[METHOD turncount_check : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
	temp: LREAL;
	ext: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//checks to see if inputed turncount will result in a outer radius over max


ext:=FALSE;


dist:=(pickup_axis_list[1].pancake.radius)/1000; 
	
	FOR i:=1 TO numOfEnabledPayoff DO
		IF payoff_axis_list[i].enabled THEN
			temp:=temp + ( desiredTurnCountPickup  *payoff_axis_list[i].tape_info^[payoff_axis_list[i].tapeType].tape_depth)/(1000);
		END_IF
		dist:=dist+temp;
		
	END_FOR


//max outer radius check
IF dist*1000 >= GVL.MAX_PICKUP_RADIUS THEN
			
	ADSLOGDINT(msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_MSGBOX, msgFmtStr := 'Winding stopped, calculated final radius above maximum radius limit, please lower turncount. Pickup Axis: %d', dintArg := 1);
	
	ext :=TRUE;
		
END_IF


turncount_check:=ext;]]></ST>
      </Implementation>
    </Method>
    <Method Name="update_axis_distance" Id="{66fdf023-25cc-43be-86f3-ed799e674baa}" FolderPath="Methods\Calculations\">
      <Declaration><![CDATA[METHOD update_axis_distance : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[pickup_axis_list[1].outerRadiusCurrent:=get_dist_to_axis_pickup();

FOR i:=1 TO gvl.MAX_PAYOFF_COUNT DO
	IF payoff_axis_list[i].enabled THEN
		payoff_axis_list[i].outerRadiusCurrent:=payoff_axis_list[i].getDistToAxis();
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="update_error_status" Id="{8a130ded-d455-41f2-ac7c-8c70dbeb7a89}" FolderPath="Methods\HMI updates\">
      <Declaration><![CDATA[METHOD update_error_status : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//updates hmi datagrids relating to axis error status and ID

hmiConnection^.output_error_datagrid_list[0].errorStatus:=pickup_axis_list[1].AXIS.Status.Error;
hmiConnection^.output_error_datagrid_list[0].errorID:=pickup_axis_list[1].AXIS.Status.ErrorID;

hmiConnection^.motor_state_datagrid_list[0].state:=pickup_axis_list[1].state;

FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	hmiConnection^.output_error_datagrid_list[i].errorStatus:=payoff_axis_list[i].AXIS.Status.Error;
	hmiConnection^.output_error_datagrid_list[i].errorID:=payoff_axis_list[i].AXIS.Status.ErrorID;
	
	hmiConnection^.motor_state_datagrid_list[i].state:=payoff_axis_list[i].state;
	
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="update_TC" Id="{af86de83-13e3-4387-9393-79bac0892f14}" FolderPath="Methods\Calculations\">
      <Declaration><![CDATA[METHOD update_TC : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[

target_turn_count:=desiredTurnCountPickup;]]></ST>
      </Implementation>
    </Method>
    <Method Name="update_torque" Id="{ea80d7c9-b122-46ba-af4e-b3e883f32cba}" FolderPath="Methods\HMI updates\">
      <Declaration><![CDATA[METHOD update_torque : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//update act ual torque values ofc motors. send these values to HMI

pickup_axis_list[1].getTorque();
hmiConnection^.torque[1]:=pickup_axis_list[1].actualTorque;
hmiConnection^.motor_info_datagrid_list[1].torque:=hmiConnection^.torque[1];

FOR i:= 1 TO GVL.MAX_PAYOFF_COUNT DO
	payoff_axis_list[i].getTorque();
	hmiConnection^.torque[i+1]:=payoff_axis_list[i].actualTorque;
	hmiConnection^.motor_info_datagrid_list[i+1].torque:=payoff_axis_list[i].actualTorque;;
END_FOR


]]></ST>
      </Implementation>
    </Method>
    <Method Name="update_velocity" Id="{e3d6da1b-3c09-4f36-8e11-85f4c14af595}" FolderPath="Methods\HMI updates\">
      <Declaration><![CDATA[METHOD update_velocity : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//update act ual torque values ofc motors. send these values to HMI


hmiConnection^.rpm[1]:=pickup_axis_list[1].actualVelocity;
hmiConnection^.rpm[2]:=payoff_axis_list[1].actualVelocity;
hmiConnection^.rpm[3]:=payoff_axis_list[2].actualVelocity;
hmiConnection^.rpm[4]:=payoff_axis_list[3].actualVelocity;


hmiConnection^.motor_info_datagrid_list[1].speed:=hmiConnection^.rpm[1];
hmiConnection^.motor_info_datagrid_list[2].speed:=hmiConnection^.rpm[2];
hmiConnection^.motor_info_datagrid_list[3].speed:=hmiConnection^.rpm[3];
hmiConnection^.motor_info_datagrid_list[4].speed:=hmiConnection^.rpm[4];]]></ST>
      </Implementation>
    </Method>
    <Method Name="winding_check" Id="{31081dd9-0820-42d0-a9d6-769c3442a1c8}" FolderPath="Methods\Checks\Input Checks\">
      <Declaration><![CDATA[METHOD winding_check : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//checks inputs to see if we can start winding.

winding_check:= winding_check OR turncount_check();]]></ST>
      </Implementation>
    </Method>
    <Method Name="winding_exit_check" Id="{d54735ba-4782-466e-8281-2700698b8cff}" FolderPath="Methods\Checks\Exit Checks\">
      <Declaration><![CDATA[METHOD winding_exit_check : BOOL
VAR_INPUT
END_VAR

VAR
	ext : BOOL :=FAlse;
	i: INT;
	ste : INT :=-1;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Checks to see if various conditions are met to exit

//turn count condition.

IF pickup_axis_list[1].AXIS.NcToPlc.ModuloActTurns >= target_turn_count THEN

	
	ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_MSGBOX, msgFmtStr := 'Winding stopped, pickup turn count reached', strArg:= '');
	ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG, msgFmtStr := 'Winding stopped, pickup turn count reached', strArg:= '');
	ext := TRUE;
	
END_IF

//inner radius reached check
IF pickup_axis_list[1].outerRadiusCurrent*0.99*1000 <= GVL.MIN_MOUNT_RADIUS THEN
			
	ADSLOGDINT(msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_MSGBOX, msgFmtStr := 'Winding stopped, calculated current radius dropped below inner radius. PICKUP AXIS ID: %d', dintArg := 1);
	ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG, msgFmtStr := 'Winding stopped, calculated current radius dropped below inner radius. PICKUP AXIS ID: %S', strArg := INT_TO_STRING(1));
	ext :=TRUE;
		
END_IF

FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
	IF payoff_axis_list[i].enabled THEN
		IF payoff_axis_list[i].outerRadiusCurrent*0.99*1000 <= GVL.MIN_MOUNT_RADIUS THEN
			
			ADSLOGDINT(msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_MSGBOX, msgFmtStr := 'Winding stopped, calculated current radius dropped below inner radius. PAYOFF AXIS ID: %d', dintArg := i);
			ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG, msgFmtStr := 'Winding stopped, calculated current radius dropped below inner radius. PAYOFF AXIS ID: %S', strArg := INT_TO_STRING(i));
	ext :=TRUE;
		
		END_IF
	
	END_IF
END_FOR

//max outer radius check
IF pickup_axis_list[1].outerRadiusCurrent*1.01*1000 >= GVL.MAX_PICKUP_RADIUS THEN
			
	ADSLOGDINT(msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_MSGBOX, msgFmtStr := 'Winding stopped, calculated current radius raised above max outer radius. PICKUP AXIS ID: %d', dintArg := 1);
	ADSLOGSTR(msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_LOG, msgFmtStr := 'Winding stopped, calculated current radius raised above max outer radius. PICKUP AXIS ID: %S', strArg := INT_TO_STRING(1));
	ext :=TRUE;
		
END_IF

FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
	IF payoff_axis_list[i].enabled THEN
		IF payoff_axis_list[i].outerRadiusCurrent*1.01*1000 >= GVL.MAX_PAYOFF_RADIUS THEN
			
			ADSLOGDINT(msgCtrlMask := ADSLOG_MSGTYPE_HINT OR ADSLOG_MSGTYPE_MSGBOX, msgFmtStr := 'Winding stopped, calculated current radius raised above max outer radius. PAYOFF AXIS ID: %d', dintArg := i);
	
	ext :=TRUE;
		
		END_IF
	
	END_IF
END_FOR

winding_exit_check:=ext;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="winding_tension" Id="{b4e997d8-0092-4fca-a6b8-7c2e056fe739}" FolderPath="Methods\Motor Control\Winding Methods\">
      <Declaration><![CDATA[METHOD winding_tension : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
	
	desiredVelocity : LREAL;
	pickupLinspeed: LREAL;
	adjustedVelocity: LREAL;
	
END_VAR
VAR CONSTANT
	PERCENT_DIFFERENCE: LREAL := 1.1;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF unwinding THEN
	//to do update with unwinding feature
	
	//do nothing, not implemneted yet. 
ELSE
	


	pickup_axis_list[1].torque:=desiredTension*numOfEnabledPayoff * get_dist_to_axis_pickup()+GVL.MIN_THRESHOLD_TORQUE;
	
	//TO DO . need to confirm these are correct
	//how i envison the limits to function is that the pickup side will gradually ramp up speed until we hit the upper velocity limit. we could maybe have no limits and just have only torque control
	//will need testing. 
	pickup_axis_list[1].velocityLimitLow:=0;
	pickup_axis_list[1].velocityLimitHigh:=(desiredLinspeed/pickup_axis_list[1].outerRadiusCurrent)*57.29578 ;
	
	pickup_axis_list[1].setTorque();
	
	pickupLinspeed:=pickup_axis_list[1].AXIS.NcToPlc.ActVelo*pickup_axis_list[1].outerRadiusCurrent/57.29578;
	
	
	
	FOR i:=1 TO GVL.MAX_PAYOFF_COUNT DO
		IF payoff_axis_list[i].enabled THEN
		
			
			
			
			payoff_axis_list[i].setVelocity();
			dist:=payoff_axis_list[i].outerRadiusCurrent;
		
			//find the velocity (degree/s) to acheive our desired linear speed, and the linear speed at pickup motor. 
			desiredVelocity:=(desiredLinspeed/payoff_axis_list[i].outerRadiusCurrent)*57.29578 ;
			adjustedVelocity:=(pickupLinspeed/payoff_axis_list[i].outerRadiusCurrent)*57.29578;
			
			
			
			//sets payoff axis to half way point between target linspeed and the actual linspeed.
			//how i envison this to function, is that while pickup side is at a low speed, the payoff side will also work at a lower speed,
			//which gives the pickup time to catch up in speed. right now i do this by just averaging desired speed and actual speed,
			//this could maybe he handled in a better way, so i will leave a TO DO 
			payoff_axis_list[i].velocity:=(0.05*desiredVelocity+adjustedVelocity*0.95);
			
			
			
		END_IF
	END_FOR 
END_IF
	
	]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_WindingControl">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.accelerating_tension">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.count_enabled_motors">
      <LineId Id="6" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="9" Count="3" />
      <LineId Id="17" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.CYCLIC">
      <LineId Id="1324" Count="1" />
      <LineId Id="2337" Count="0" />
      <LineId Id="1326" Count="0" />
      <LineId Id="2000" Count="138" />
      <LineId Id="2148" Count="40" />
      <LineId Id="2199" Count="34" />
      <LineId Id="2359" Count="0" />
      <LineId Id="2245" Count="69" />
      <LineId Id="2324" Count="0" />
      <LineId Id="2326" Count="10" />
      <LineId Id="1728" Count="40" />
      <LineId Id="2338" Count="0" />
      <LineId Id="1769" Count="3" />
      <LineId Id="2339" Count="0" />
      <LineId Id="1773" Count="159" />
      <LineId Id="2340" Count="0" />
      <LineId Id="1933" Count="16" />
      <LineId Id="2341" Count="0" />
      <LineId Id="1950" Count="13" />
      <LineId Id="2343" Count="0" />
      <LineId Id="1964" Count="1" />
      <LineId Id="2344" Count="3" />
      <LineId Id="2342" Count="0" />
      <LineId Id="1966" Count="22" />
      <LineId Id="544" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.decelerating_tension">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.determine_motor_state">
      <LineId Id="14" Count="0" />
      <LineId Id="16" Count="2" />
      <LineId Id="20" Count="1" />
      <LineId Id="33" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="26" Count="1" />
      <LineId Id="37" Count="1" />
      <LineId Id="46" Count="0" />
      <LineId Id="39" Count="1" />
      <LineId Id="45" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="29" Count="1" />
      <LineId Id="28" Count="0" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.estop_routine">
      <LineId Id="8" Count="4" />
      <LineId Id="84" Count="0" />
      <LineId Id="86" Count="1" />
      <LineId Id="85" Count="0" />
      <LineId Id="77" Count="1" />
      <LineId Id="81" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="63" Count="8" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.find_actualLinspeed">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.find_eta">
      <LineId Id="22" Count="9" />
      <LineId Id="74" Count="0" />
      <LineId Id="143" Count="2" />
      <LineId Id="162" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="161" Count="0" />
      <LineId Id="149" Count="4" />
      <LineId Id="155" Count="0" />
      <LineId Id="213" Count="0" />
      <LineId Id="156" Count="1" />
      <LineId Id="159" Count="1" />
      <LineId Id="181" Count="0" />
      <LineId Id="185" Count="1" />
      <LineId Id="182" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="50" Count="1" />
      <LineId Id="35" Count="1" />
      <LineId Id="52" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="215" Count="1" />
      <LineId Id="38" Count="0" />
      <LineId Id="217" Count="1" />
      <LineId Id="39" Count="3" />
      <LineId Id="206" Count="0" />
      <LineId Id="43" Count="2" />
      <LineId Id="208" Count="0" />
      <LineId Id="207" Count="0" />
      <LineId Id="209" Count="0" />
      <LineId Id="211" Count="1" />
      <LineId Id="210" Count="0" />
      <LineId Id="46" Count="3" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.find_tape_length_used">
      <LineId Id="10" Count="6" />
      <LineId Id="71" Count="4" />
      <LineId Id="22" Count="1" />
      <LineId Id="28" Count="1" />
      <LineId Id="44" Count="8" />
      <LineId Id="61" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.freespin_all">
      <LineId Id="21" Count="1" />
      <LineId Id="7" Count="7" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.general_error_check">
      <LineId Id="20" Count="0" />
      <LineId Id="66" Count="2" />
      <LineId Id="31" Count="2" />
      <LineId Id="84" Count="9" />
      <LineId Id="22" Count="0" />
      <LineId Id="106" Count="10" />
      <LineId Id="105" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="23" Count="2" />
      <LineId Id="70" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="26" Count="1" />
      <LineId Id="29" Count="0" />
      <LineId Id="117" Count="21" />
      <LineId Id="47" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.general_input_check">
      <LineId Id="55" Count="1" />
      <LineId Id="6" Count="9" />
      <LineId Id="33" Count="1" />
      <LineId Id="42" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="19" Count="11" />
      <LineId Id="43" Count="2" />
      <LineId Id="31" Count="1" />
      <LineId Id="18" Count="0" />
      <LineId Id="47" Count="3" />
      <LineId Id="46" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.get_current_progress">
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="35" Count="0" />
      <LineId Id="31" Count="1" />
      <LineId Id="30" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="36" Count="1" />
      <LineId Id="26" Count="0" />
      <LineId Id="11" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.get_dist_to_axis_pickup">
      <LineId Id="6" Count="11" />
      <LineId Id="83" Count="8" />
      <LineId Id="38" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="50" Count="1" />
      <LineId Id="68" Count="1" />
      <LineId Id="92" Count="5" />
      <LineId Id="24" Count="9" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.hmi_update">
      <LineId Id="8" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="38" Count="1" />
      <LineId Id="47" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="50" Count="1" />
      <LineId Id="53" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="79" Count="3" />
      <LineId Id="78" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.home">
      <LineId Id="92" Count="0" />
      <LineId Id="109" Count="2" />
      <LineId Id="124" Count="7" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.INIT">
      <LineId Id="5" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="27" Count="1" />
      <LineId Id="31" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="26" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="13" Count="1" />
      <LineId Id="32" Count="1" />
      <LineId Id="30" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="56" Count="1" />
      <LineId Id="55" Count="0" />
      <LineId Id="58" Count="2" />
    </LineIds>
    <LineIds Name="FB_WindingControl.init_coil_model">
      <LineId Id="52" Count="1" />
      <LineId Id="49" Count="2" />
      <LineId Id="16" Count="31" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.payoff_input_check">
      <LineId Id="35" Count="0" />
      <LineId Id="133" Count="0" />
      <LineId Id="132" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="112" Count="0" />
      <LineId Id="122" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="71" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.read_status">
      <LineId Id="6" Count="6" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.reset">
      <LineId Id="50" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="20" Count="3" />
      <LineId Id="39" Count="2" />
      <LineId Id="43" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="25" Count="5" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.set_pos_all">
      <LineId Id="123" Count="0" />
      <LineId Id="21" Count="3" />
      <LineId Id="52" Count="4" />
      <LineId Id="25" Count="0" />
      <LineId Id="70" Count="3" />
      <LineId Id="26" Count="1" />
      <LineId Id="74" Count="1" />
      <LineId Id="59" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="120" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="64" Count="2" />
      <LineId Id="69" Count="0" />
      <LineId Id="77" Count="1" />
      <LineId Id="68" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="86" Count="1" />
      <LineId Id="30" Count="1" />
      <LineId Id="88" Count="0" />
      <LineId Id="32" Count="1" />
      <LineId Id="93" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="97" Count="3" />
      <LineId Id="116" Count="0" />
      <LineId Id="101" Count="1" />
      <LineId Id="117" Count="0" />
      <LineId Id="119" Count="0" />
      <LineId Id="137" Count="0" />
      <LineId Id="118" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="149" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="82" Count="2" />
      <LineId Id="34" Count="0" />
      <LineId Id="39" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.standstill_tension">
      <LineId Id="23" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="107" Count="0" />
      <LineId Id="53" Count="11" />
      <LineId Id="73" Count="0" />
      <LineId Id="96" Count="2" />
      <LineId Id="65" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.standstill_tension_check">
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="47" Count="3" />
      <LineId Id="18" Count="2" />
      <LineId Id="25" Count="1" />
      <LineId Id="16" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="71" Count="4" />
      <LineId Id="69" Count="1" />
      <LineId Id="41" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="52" Count="3" />
      <LineId Id="51" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="43" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.stop_all">
      <LineId Id="44" Count="1" />
      <LineId Id="20" Count="1" />
      <LineId Id="25" Count="3" />
      <LineId Id="30" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.transfer_hmi_vars">
      <LineId Id="6" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="21" Count="5" />
      <LineId Id="42" Count="1" />
      <LineId Id="20" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.turncount_check">
      <LineId Id="5" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="32" Count="7" />
      <LineId Id="30" Count="1" />
      <LineId Id="7" Count="8" />
      <LineId Id="52" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="44" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.update_axis_distance">
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="13" Count="1" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.update_error_status">
      <LineId Id="45" Count="1" />
      <LineId Id="5" Count="1" />
      <LineId Id="35" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="8" Count="1" />
      <LineId Id="12" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="36" Count="1" />
      <LineId Id="27" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.update_TC">
      <LineId Id="6" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.update_torque">
      <LineId Id="6" Count="2" />
      <LineId Id="12" Count="3" />
      <LineId Id="17" Count="1" />
      <LineId Id="29" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="42" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.update_velocity">
      <LineId Id="6" Count="4" />
      <LineId Id="25" Count="1" />
      <LineId Id="11" Count="0" />
      <LineId Id="17" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="33" Count="1" />
    </LineIds>
    <LineIds Name="FB_WindingControl.winding_check">
      <LineId Id="9" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.winding_exit_check">
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="9" Count="1" />
      <LineId Id="68" Count="0" />
      <LineId Id="11" Count="1" />
      <LineId Id="125" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="91" Count="2" />
      <LineId Id="128" Count="0" />
      <LineId Id="94" Count="1" />
      <LineId Id="90" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="48" Count="1" />
      <LineId Id="123" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="105" Count="2" />
      <LineId Id="126" Count="0" />
      <LineId Id="108" Count="2" />
      <LineId Id="132" Count="11" />
      <LineId Id="122" Count="0" />
      <LineId Id="131" Count="0" />
      <LineId Id="130" Count="0" />
      <LineId Id="74" Count="0" />
    </LineIds>
    <LineIds Name="FB_WindingControl.winding_tension">
      <LineId Id="31" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="177" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="69" Count="2" />
      <LineId Id="178" Count="1" />
      <LineId Id="72" Count="4" />
      <LineId Id="121" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="122" Count="1" />
      <LineId Id="77" Count="3" />
      <LineId Id="103" Count="1" />
      <LineId Id="81" Count="1" />
      <LineId Id="162" Count="0" />
      <LineId Id="113" Count="1" />
      <LineId Id="132" Count="0" />
      <LineId Id="115" Count="0" />
      <LineId Id="204" Count="0" />
      <LineId Id="199" Count="0" />
      <LineId Id="120" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="180" Count="1" />
      <LineId Id="131" Count="0" />
      <LineId Id="83" Count="3" />
      <LineId Id="67" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="34" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>